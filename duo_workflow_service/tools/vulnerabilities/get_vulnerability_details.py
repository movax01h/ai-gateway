import json
from typing import Any, Type

from pydantic import BaseModel, Field

from duo_workflow_service.tools.duo_base_tool import DuoBaseTool
from duo_workflow_service.tools.vulnerabilities.queries.vulnerabilities import (
    GET_VULNERABILITY_DETAILS_QUERY,
)


class GetVulnerabilityDetailsInput(BaseModel):
    vulnerability_id: str = Field(
        description="The numeric ID of the vulnerability (e.g., '567'), as seen in the main project Vulnerability Report. Do not use a UUID here.",
    )


class GetVulnerabilityDetails(DuoBaseTool):
    """Tool for fetching detailed information about a persisted project vulnerability."""

    name: str = "get_vulnerability_details"
    description: str = """Use this tool to get details for a specific vulnerability identified by its numeric ID.

    A "Vulnerability" is a persisted security issue found in the main project Vulnerability Report, identified by a simple numeric ID.

    **Use this tool when you have a numeric ID (e.g., '567').**

    This tool provides comprehensive details including:
    - Basic vulnerability information (title, state, description, severity)
    - Location details (file paths, line numbers, etc.)
    - CVE enrichment data (EPSS scores, known exploits)
    - Detection pipeline information
    - FP detection metadata (flags, confidence scores, reasoning)
    - Detailed vulnerability report data with nested structures

    FP Detection Metadata:
    - `latestFlag`: The most recent FP detection result with status, confidence score, and reasoning

    This is different from a "Security Finding", which is a potential issue from a pipeline scan and has a UUID.
    **Do NOT use this tool for UUIDs; use the 'get_security_finding_details' tool when you have a UUID.**


    For example:
        get_vulnerability_details(vulnerability_id="567")
    """
    args_schema: Type[BaseModel] = GetVulnerabilityDetailsInput

    async def _execute(self, **kwargs: Any) -> str:
        vulnerability_id = kwargs.pop("vulnerability_id")

        try:
            # Convert numeric ID to full GraphQL ID format
            if not vulnerability_id.isdigit():
                return json.dumps(
                    {
                        "error": f"Invalid vulnerability ID: {vulnerability_id}. Must be numeric."
                    }
                )
            full_vulnerability_id = f"gid://gitlab/Vulnerability/{vulnerability_id}"
            variables = {
                "vulnerabilityId": full_vulnerability_id,
            }

            response = await self.gitlab_client.apost(
                path="/api/graphql",
                body=json.dumps(
                    {"query": GET_VULNERABILITY_DETAILS_QUERY, "variables": variables}
                ),
            )

            response = self._process_http_response(
                identifier="GetVulnerabilityDetails", response=response
            )

            if "errors" in response:
                return json.dumps({"error": response["errors"]})

            vulnerability = response.get("data", {}).get("vulnerability")

            if not vulnerability:
                return json.dumps(
                    {"error": f"Vulnerability with ID {vulnerability_id} not found"}
                )

            return json.dumps({"vulnerability": vulnerability})
        except Exception as e:
            return json.dumps({"error": str(e)})

    def format_display_message(
        self, args: GetVulnerabilityDetailsInput, _tool_response: Any = None
    ) -> str:
        return f"Get details for vulnerability {args.vulnerability_id}"


class EvaluateFPStatusInput(BaseModel):
    vulnerability_json: str = Field(
        description="JSON string from get_vulnerability_details"
    )


class EvaluateVulnerabilityFalsePositiveStatus(DuoBaseTool):
    name: str = "evaluate_vuln_fp_status"
    description: str = (
        "Evaluates existing false positive status from vulnerability data"
    )
    args_schema: Type[BaseModel] = EvaluateFPStatusInput

    CONFIDENCE_THRESHOLD: float = 0.6

    async def _execute(self, vulnerability_json: str) -> str:
        try:
            data: dict = (
                json.loads(vulnerability_json)
                if isinstance(vulnerability_json, str)
                else vulnerability_json or {}
            )
        except (json.JSONDecodeError, TypeError):
            return "proceed_with_fix"

        flag: dict = data.get("vulnerability", {}).get("latestFlag") or {}
        confidence: float | None = flag.get("confidenceScore")

        if confidence is not None and confidence >= self.CONFIDENCE_THRESHOLD:
            return "skip_false_positive"
        return "proceed_with_fix"
