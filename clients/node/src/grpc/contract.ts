// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.27.3
// source: contract.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "";

export enum ContextElementType {
  USER_PREFERENCE = 0,
  SELECTED_TEXT = 1,
  FILE = 2,
  ISSUE = 3,
  MERGE_REQUEST = 4,
  PREVIOUS_WORKFLOW = 5,
  UNRECOGNIZED = -1,
}

export function contextElementTypeFromJSON(object: any): ContextElementType {
  switch (object) {
    case 0:
    case "USER_PREFERENCE":
      return ContextElementType.USER_PREFERENCE;
    case 1:
    case "SELECTED_TEXT":
      return ContextElementType.SELECTED_TEXT;
    case 2:
    case "FILE":
      return ContextElementType.FILE;
    case 3:
    case "ISSUE":
      return ContextElementType.ISSUE;
    case 4:
    case "MERGE_REQUEST":
      return ContextElementType.MERGE_REQUEST;
    case 5:
    case "PREVIOUS_WORKFLOW":
      return ContextElementType.PREVIOUS_WORKFLOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContextElementType.UNRECOGNIZED;
  }
}

export function contextElementTypeToJSON(object: ContextElementType): string {
  switch (object) {
    case ContextElementType.USER_PREFERENCE:
      return "USER_PREFERENCE";
    case ContextElementType.SELECTED_TEXT:
      return "SELECTED_TEXT";
    case ContextElementType.FILE:
      return "FILE";
    case ContextElementType.ISSUE:
      return "ISSUE";
    case ContextElementType.MERGE_REQUEST:
      return "MERGE_REQUEST";
    case ContextElementType.PREVIOUS_WORKFLOW:
      return "PREVIOUS_WORKFLOW";
    case ContextElementType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ClientEvent {
  startRequest?: StartWorkflowRequest | undefined;
  actionResponse?: ActionResponse | undefined;
}

export interface StartWorkflowRequest {
  clientVersion: string;
  workflowID: string;
  workflowDefinition: string;
  goal: string;
  workflowMetadata: string;
  clientCapabilities: string[];
  context: ContextElement[];
}

export interface ActionResponse {
  requestID: string;
  response: string;
}

export interface Action {
  requestID: string;
  runCommand?: RunCommandAction | undefined;
  runHTTPRequest?: RunHTTPRequest | undefined;
  runReadFile?: ReadFile | undefined;
  runWriteFile?: WriteFile | undefined;
  runGitCommand?: RunGitCommand | undefined;
  runEditFile?: EditFile | undefined;
  newCheckpoint?: NewCheckpoint | undefined;
}

export interface RunCommandAction {
  program: string;
  arguments: string[];
  flags: string[];
}

export interface ReadFile {
  filepath: string;
}

export interface WriteFile {
  filepath: string;
  contents: string;
}

export interface EditFile {
  filepath: string;
  oldString: string;
  newString: string;
}

export interface RunHTTPRequest {
  method: string;
  path: string;
  body?: string | undefined;
}

export interface RunGitCommand {
  command: string;
  arguments?: string | undefined;
  repositoryUrl: string;
}

export interface GenerateTokenRequest {
}

export interface GenerateTokenResponse {
  token: string;
  expiresAt: number;
}

export interface ContextElement {
  type: ContextElementType;
  name: string;
  contents: string;
}

export interface NewCheckpoint {
  status: string;
  checkpoint: string;
  goal: string;
  errors: string[];
}

function createBaseClientEvent(): ClientEvent {
  return { startRequest: undefined, actionResponse: undefined };
}

export const ClientEvent: MessageFns<ClientEvent> = {
  encode(message: ClientEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startRequest !== undefined) {
      StartWorkflowRequest.encode(message.startRequest, writer.uint32(10).fork()).join();
    }
    if (message.actionResponse !== undefined) {
      ActionResponse.encode(message.actionResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startRequest = StartWorkflowRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actionResponse = ActionResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent {
    return {
      startRequest: isSet(object.startRequest) ? StartWorkflowRequest.fromJSON(object.startRequest) : undefined,
      actionResponse: isSet(object.actionResponse) ? ActionResponse.fromJSON(object.actionResponse) : undefined,
    };
  },

  toJSON(message: ClientEvent): unknown {
    const obj: any = {};
    if (message.startRequest !== undefined) {
      obj.startRequest = StartWorkflowRequest.toJSON(message.startRequest);
    }
    if (message.actionResponse !== undefined) {
      obj.actionResponse = ActionResponse.toJSON(message.actionResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent>, I>>(base?: I): ClientEvent {
    return ClientEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent>, I>>(object: I): ClientEvent {
    const message = createBaseClientEvent();
    message.startRequest = (object.startRequest !== undefined && object.startRequest !== null)
      ? StartWorkflowRequest.fromPartial(object.startRequest)
      : undefined;
    message.actionResponse = (object.actionResponse !== undefined && object.actionResponse !== null)
      ? ActionResponse.fromPartial(object.actionResponse)
      : undefined;
    return message;
  },
};

function createBaseStartWorkflowRequest(): StartWorkflowRequest {
  return {
    clientVersion: "",
    workflowID: "",
    workflowDefinition: "",
    goal: "",
    workflowMetadata: "",
    clientCapabilities: [],
    context: [],
  };
}

export const StartWorkflowRequest: MessageFns<StartWorkflowRequest> = {
  encode(message: StartWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientVersion !== "") {
      writer.uint32(10).string(message.clientVersion);
    }
    if (message.workflowID !== "") {
      writer.uint32(18).string(message.workflowID);
    }
    if (message.workflowDefinition !== "") {
      writer.uint32(26).string(message.workflowDefinition);
    }
    if (message.goal !== "") {
      writer.uint32(34).string(message.goal);
    }
    if (message.workflowMetadata !== "") {
      writer.uint32(42).string(message.workflowMetadata);
    }
    for (const v of message.clientCapabilities) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.context) {
      ContextElement.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowDefinition = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowMetadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientCapabilities.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.context.push(ContextElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowRequest {
    return {
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
      workflowDefinition: isSet(object.workflowDefinition) ? globalThis.String(object.workflowDefinition) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      workflowMetadata: isSet(object.workflowMetadata) ? globalThis.String(object.workflowMetadata) : "",
      clientCapabilities: globalThis.Array.isArray(object?.clientCapabilities)
        ? object.clientCapabilities.map((e: any) => globalThis.String(e))
        : [],
      context: globalThis.Array.isArray(object?.context)
        ? object.context.map((e: any) => ContextElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartWorkflowRequest): unknown {
    const obj: any = {};
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    if (message.workflowDefinition !== "") {
      obj.workflowDefinition = message.workflowDefinition;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.workflowMetadata !== "") {
      obj.workflowMetadata = message.workflowMetadata;
    }
    if (message.clientCapabilities?.length) {
      obj.clientCapabilities = message.clientCapabilities;
    }
    if (message.context?.length) {
      obj.context = message.context.map((e) => ContextElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(base?: I): StartWorkflowRequest {
    return StartWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(object: I): StartWorkflowRequest {
    const message = createBaseStartWorkflowRequest();
    message.clientVersion = object.clientVersion ?? "";
    message.workflowID = object.workflowID ?? "";
    message.workflowDefinition = object.workflowDefinition ?? "";
    message.goal = object.goal ?? "";
    message.workflowMetadata = object.workflowMetadata ?? "";
    message.clientCapabilities = object.clientCapabilities?.map((e) => e) || [];
    message.context = object.context?.map((e) => ContextElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActionResponse(): ActionResponse {
  return { requestID: "", response: "" };
}

export const ActionResponse: MessageFns<ActionResponse> = {
  encode(message: ActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.response !== "") {
      writer.uint32(18).string(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      response: isSet(object.response) ? globalThis.String(object.response) : "",
    };
  },

  toJSON(message: ActionResponse): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.response !== "") {
      obj.response = message.response;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionResponse>, I>>(base?: I): ActionResponse {
    return ActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionResponse>, I>>(object: I): ActionResponse {
    const message = createBaseActionResponse();
    message.requestID = object.requestID ?? "";
    message.response = object.response ?? "";
    return message;
  },
};

function createBaseAction(): Action {
  return {
    requestID: "",
    runCommand: undefined,
    runHTTPRequest: undefined,
    runReadFile: undefined,
    runWriteFile: undefined,
    runGitCommand: undefined,
    runEditFile: undefined,
    newCheckpoint: undefined,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.runCommand !== undefined) {
      RunCommandAction.encode(message.runCommand, writer.uint32(18).fork()).join();
    }
    if (message.runHTTPRequest !== undefined) {
      RunHTTPRequest.encode(message.runHTTPRequest, writer.uint32(26).fork()).join();
    }
    if (message.runReadFile !== undefined) {
      ReadFile.encode(message.runReadFile, writer.uint32(34).fork()).join();
    }
    if (message.runWriteFile !== undefined) {
      WriteFile.encode(message.runWriteFile, writer.uint32(42).fork()).join();
    }
    if (message.runGitCommand !== undefined) {
      RunGitCommand.encode(message.runGitCommand, writer.uint32(50).fork()).join();
    }
    if (message.runEditFile !== undefined) {
      EditFile.encode(message.runEditFile, writer.uint32(58).fork()).join();
    }
    if (message.newCheckpoint !== undefined) {
      NewCheckpoint.encode(message.newCheckpoint, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runCommand = RunCommandAction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runHTTPRequest = RunHTTPRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runReadFile = ReadFile.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runWriteFile = WriteFile.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.runGitCommand = RunGitCommand.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.runEditFile = EditFile.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.newCheckpoint = NewCheckpoint.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      runCommand: isSet(object.runCommand) ? RunCommandAction.fromJSON(object.runCommand) : undefined,
      runHTTPRequest: isSet(object.runHTTPRequest) ? RunHTTPRequest.fromJSON(object.runHTTPRequest) : undefined,
      runReadFile: isSet(object.runReadFile) ? ReadFile.fromJSON(object.runReadFile) : undefined,
      runWriteFile: isSet(object.runWriteFile) ? WriteFile.fromJSON(object.runWriteFile) : undefined,
      runGitCommand: isSet(object.runGitCommand) ? RunGitCommand.fromJSON(object.runGitCommand) : undefined,
      runEditFile: isSet(object.runEditFile) ? EditFile.fromJSON(object.runEditFile) : undefined,
      newCheckpoint: isSet(object.newCheckpoint) ? NewCheckpoint.fromJSON(object.newCheckpoint) : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.runCommand !== undefined) {
      obj.runCommand = RunCommandAction.toJSON(message.runCommand);
    }
    if (message.runHTTPRequest !== undefined) {
      obj.runHTTPRequest = RunHTTPRequest.toJSON(message.runHTTPRequest);
    }
    if (message.runReadFile !== undefined) {
      obj.runReadFile = ReadFile.toJSON(message.runReadFile);
    }
    if (message.runWriteFile !== undefined) {
      obj.runWriteFile = WriteFile.toJSON(message.runWriteFile);
    }
    if (message.runGitCommand !== undefined) {
      obj.runGitCommand = RunGitCommand.toJSON(message.runGitCommand);
    }
    if (message.runEditFile !== undefined) {
      obj.runEditFile = EditFile.toJSON(message.runEditFile);
    }
    if (message.newCheckpoint !== undefined) {
      obj.newCheckpoint = NewCheckpoint.toJSON(message.newCheckpoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.requestID = object.requestID ?? "";
    message.runCommand = (object.runCommand !== undefined && object.runCommand !== null)
      ? RunCommandAction.fromPartial(object.runCommand)
      : undefined;
    message.runHTTPRequest = (object.runHTTPRequest !== undefined && object.runHTTPRequest !== null)
      ? RunHTTPRequest.fromPartial(object.runHTTPRequest)
      : undefined;
    message.runReadFile = (object.runReadFile !== undefined && object.runReadFile !== null)
      ? ReadFile.fromPartial(object.runReadFile)
      : undefined;
    message.runWriteFile = (object.runWriteFile !== undefined && object.runWriteFile !== null)
      ? WriteFile.fromPartial(object.runWriteFile)
      : undefined;
    message.runGitCommand = (object.runGitCommand !== undefined && object.runGitCommand !== null)
      ? RunGitCommand.fromPartial(object.runGitCommand)
      : undefined;
    message.runEditFile = (object.runEditFile !== undefined && object.runEditFile !== null)
      ? EditFile.fromPartial(object.runEditFile)
      : undefined;
    message.newCheckpoint = (object.newCheckpoint !== undefined && object.newCheckpoint !== null)
      ? NewCheckpoint.fromPartial(object.newCheckpoint)
      : undefined;
    return message;
  },
};

function createBaseRunCommandAction(): RunCommandAction {
  return { program: "", arguments: [], flags: [] };
}

export const RunCommandAction: MessageFns<RunCommandAction> = {
  encode(message: RunCommandAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== "") {
      writer.uint32(26).string(message.program);
    }
    for (const v of message.arguments) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.flags) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunCommandAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunCommandAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.program = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.flags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunCommandAction {
    return {
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RunCommandAction): unknown {
    const obj: any = {};
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunCommandAction>, I>>(base?: I): RunCommandAction {
    return RunCommandAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunCommandAction>, I>>(object: I): RunCommandAction {
    const message = createBaseRunCommandAction();
    message.program = object.program ?? "";
    message.arguments = object.arguments?.map((e) => e) || [];
    message.flags = object.flags?.map((e) => e) || [];
    return message;
  },
};

function createBaseReadFile(): ReadFile {
  return { filepath: "" };
}

export const ReadFile: MessageFns<ReadFile> = {
  encode(message: ReadFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFile {
    return { filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "" };
  },

  toJSON(message: ReadFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFile>, I>>(base?: I): ReadFile {
    return ReadFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFile>, I>>(object: I): ReadFile {
    const message = createBaseReadFile();
    message.filepath = object.filepath ?? "";
    return message;
  },
};

function createBaseWriteFile(): WriteFile {
  return { filepath: "", contents: "" };
}

export const WriteFile: MessageFns<WriteFile> = {
  encode(message: WriteFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.contents !== "") {
      writer.uint32(18).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: WriteFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFile>, I>>(base?: I): WriteFile {
    return WriteFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFile>, I>>(object: I): WriteFile {
    const message = createBaseWriteFile();
    message.filepath = object.filepath ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseEditFile(): EditFile {
  return { filepath: "", oldString: "", newString: "" };
}

export const EditFile: MessageFns<EditFile> = {
  encode(message: EditFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.oldString !== "") {
      writer.uint32(18).string(message.oldString);
    }
    if (message.newString !== "") {
      writer.uint32(26).string(message.newString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldString = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      oldString: isSet(object.oldString) ? globalThis.String(object.oldString) : "",
      newString: isSet(object.newString) ? globalThis.String(object.newString) : "",
    };
  },

  toJSON(message: EditFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.oldString !== "") {
      obj.oldString = message.oldString;
    }
    if (message.newString !== "") {
      obj.newString = message.newString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditFile>, I>>(base?: I): EditFile {
    return EditFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditFile>, I>>(object: I): EditFile {
    const message = createBaseEditFile();
    message.filepath = object.filepath ?? "";
    message.oldString = object.oldString ?? "";
    message.newString = object.newString ?? "";
    return message;
  },
};

function createBaseRunHTTPRequest(): RunHTTPRequest {
  return { method: "", path: "", body: undefined };
}

export const RunHTTPRequest: MessageFns<RunHTTPRequest> = {
  encode(message: RunHTTPRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.body !== undefined) {
      writer.uint32(26).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunHTTPRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunHTTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunHTTPRequest {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : undefined,
    };
  },

  toJSON(message: RunHTTPRequest): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(base?: I): RunHTTPRequest {
    return RunHTTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(object: I): RunHTTPRequest {
    const message = createBaseRunHTTPRequest();
    message.method = object.method ?? "";
    message.path = object.path ?? "";
    message.body = object.body ?? undefined;
    return message;
  },
};

function createBaseRunGitCommand(): RunGitCommand {
  return { command: "", arguments: undefined, repositoryUrl: "" };
}

export const RunGitCommand: MessageFns<RunGitCommand> = {
  encode(message: RunGitCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.arguments !== undefined) {
      writer.uint32(18).string(message.arguments);
    }
    if (message.repositoryUrl !== "") {
      writer.uint32(26).string(message.repositoryUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunGitCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunGitCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repositoryUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunGitCommand {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : undefined,
      repositoryUrl: isSet(object.repositoryUrl) ? globalThis.String(object.repositoryUrl) : "",
    };
  },

  toJSON(message: RunGitCommand): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.arguments !== undefined) {
      obj.arguments = message.arguments;
    }
    if (message.repositoryUrl !== "") {
      obj.repositoryUrl = message.repositoryUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunGitCommand>, I>>(base?: I): RunGitCommand {
    return RunGitCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunGitCommand>, I>>(object: I): RunGitCommand {
    const message = createBaseRunGitCommand();
    message.command = object.command ?? "";
    message.arguments = object.arguments ?? undefined;
    message.repositoryUrl = object.repositoryUrl ?? "";
    return message;
  },
};

function createBaseGenerateTokenRequest(): GenerateTokenRequest {
  return {};
}

export const GenerateTokenRequest: MessageFns<GenerateTokenRequest> = {
  encode(_: GenerateTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerateTokenRequest {
    return {};
  },

  toJSON(_: GenerateTokenRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(base?: I): GenerateTokenRequest {
    return GenerateTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(_: I): GenerateTokenRequest {
    const message = createBaseGenerateTokenRequest();
    return message;
  },
};

function createBaseGenerateTokenResponse(): GenerateTokenResponse {
  return { token: "", expiresAt: 0 };
}

export const GenerateTokenResponse: MessageFns<GenerateTokenResponse> = {
  encode(message: GenerateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTokenResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
    };
  },

  toJSON(message: GenerateTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(base?: I): GenerateTokenResponse {
    return GenerateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(object: I): GenerateTokenResponse {
    const message = createBaseGenerateTokenResponse();
    message.token = object.token ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function createBaseContextElement(): ContextElement {
  return { type: 0, name: "", contents: "" };
}

export const ContextElement: MessageFns<ContextElement> = {
  encode(message: ContextElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.contents !== "") {
      writer.uint32(26).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContextElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextElement {
    return {
      type: isSet(object.type) ? contextElementTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: ContextElement): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = contextElementTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextElement>, I>>(base?: I): ContextElement {
    return ContextElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextElement>, I>>(object: I): ContextElement {
    const message = createBaseContextElement();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseNewCheckpoint(): NewCheckpoint {
  return { status: "", checkpoint: "", goal: "", errors: [] };
}

export const NewCheckpoint: MessageFns<NewCheckpoint> = {
  encode(message: NewCheckpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.checkpoint !== "") {
      writer.uint32(18).string(message.checkpoint);
    }
    if (message.goal !== "") {
      writer.uint32(26).string(message.goal);
    }
    for (const v of message.errors) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewCheckpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewCheckpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewCheckpoint {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      checkpoint: isSet(object.checkpoint) ? globalThis.String(object.checkpoint) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NewCheckpoint): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.checkpoint !== "") {
      obj.checkpoint = message.checkpoint;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewCheckpoint>, I>>(base?: I): NewCheckpoint {
    return NewCheckpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewCheckpoint>, I>>(object: I): NewCheckpoint {
    const message = createBaseNewCheckpoint();
    message.status = object.status ?? "";
    message.checkpoint = object.checkpoint ?? "";
    message.goal = object.goal ?? "";
    message.errors = object.errors?.map((e) => e) || [];
    return message;
  },
};

export type DuoWorkflowService = typeof DuoWorkflowService;
export const DuoWorkflowService = {
  executeWorkflow: {
    path: "/DuoWorkflow/ExecuteWorkflow",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ClientEvent) => Buffer.from(ClientEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClientEvent.decode(value),
    responseSerialize: (value: Action) => Buffer.from(Action.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Action.decode(value),
  },
  generateToken: {
    path: "/DuoWorkflow/GenerateToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateTokenRequest) => Buffer.from(GenerateTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GenerateTokenRequest.decode(value),
    responseSerialize: (value: GenerateTokenResponse) => Buffer.from(GenerateTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GenerateTokenResponse.decode(value),
  },
} as const;

export interface DuoWorkflowServer extends UntypedServiceImplementation {
  executeWorkflow: handleBidiStreamingCall<ClientEvent, Action>;
  generateToken: handleUnaryCall<GenerateTokenRequest, GenerateTokenResponse>;
}

export interface DuoWorkflowClient extends Client {
  executeWorkflow(): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(options: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  generateToken(
    request: GenerateTokenRequest,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
}

export const DuoWorkflowClient = makeGenericClientConstructor(DuoWorkflowService, "DuoWorkflow") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DuoWorkflowClient;
  service: typeof DuoWorkflowService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
