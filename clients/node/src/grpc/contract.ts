// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v5.27.3
// source: contract.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "";

export enum ContextElementType {
  USER_PREFERENCE = 0,
  SELECTED_TEXT = 1,
  FILE = 2,
  ISSUE = 3,
  MERGE_REQUEST = 4,
  PREVIOUS_WORKFLOW = 5,
  UNRECOGNIZED = -1,
}

export function contextElementTypeFromJSON(object: any): ContextElementType {
  switch (object) {
    case 0:
    case "USER_PREFERENCE":
      return ContextElementType.USER_PREFERENCE;
    case 1:
    case "SELECTED_TEXT":
      return ContextElementType.SELECTED_TEXT;
    case 2:
    case "FILE":
      return ContextElementType.FILE;
    case 3:
    case "ISSUE":
      return ContextElementType.ISSUE;
    case 4:
    case "MERGE_REQUEST":
      return ContextElementType.MERGE_REQUEST;
    case 5:
    case "PREVIOUS_WORKFLOW":
      return ContextElementType.PREVIOUS_WORKFLOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContextElementType.UNRECOGNIZED;
  }
}

export function contextElementTypeToJSON(object: ContextElementType): string {
  switch (object) {
    case ContextElementType.USER_PREFERENCE:
      return "USER_PREFERENCE";
    case ContextElementType.SELECTED_TEXT:
      return "SELECTED_TEXT";
    case ContextElementType.FILE:
      return "FILE";
    case ContextElementType.ISSUE:
      return "ISSUE";
    case ContextElementType.MERGE_REQUEST:
      return "MERGE_REQUEST";
    case ContextElementType.PREVIOUS_WORKFLOW:
      return "PREVIOUS_WORKFLOW";
    case ContextElementType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ClientEvent {
  startRequest?: StartWorkflowRequest | undefined;
  actionResponse?: ActionResponse | undefined;
}

export interface StartWorkflowRequest {
  clientVersion: string;
  workflowID: string;
  workflowDefinition: string;
  goal: string;
  workflowMetadata: string;
  clientCapabilities: string[];
  context: ContextElement[];
  mcpTools: McpTool[];
  additionalContext: AdditionalContext[];
}

export interface ActionResponse {
  requestID: string;
  response: string;
  plainTextResponse?: PlainTextResponse | undefined;
  httpResponse?: HttpResponse | undefined;
}

export interface PlainTextResponse {
  response: string;
  error: string;
}

export interface HttpResponse {
  headers: { [key: string]: string };
  statusCode: number;
  body: string;
  error: string;
}

export interface HttpResponse_HeadersEntry {
  key: string;
  value: string;
}

export interface Action {
  requestID: string;
  runCommand?: RunCommandAction | undefined;
  runHTTPRequest?: RunHTTPRequest | undefined;
  runReadFile?: ReadFile | undefined;
  runWriteFile?: WriteFile | undefined;
  runGitCommand?: RunGitCommand | undefined;
  runEditFile?: EditFile | undefined;
  newCheckpoint?: NewCheckpoint | undefined;
  listDirectory?: ListDirectory | undefined;
  grep?: Grep | undefined;
  findFiles?: FindFiles | undefined;
  runMCPTool?: RunMCPTool | undefined;
}

export interface RunCommandAction {
  program: string;
  arguments: string[];
  flags: string[];
}

export interface ReadFile {
  filepath: string;
}

export interface WriteFile {
  filepath: string;
  contents: string;
}

export interface EditFile {
  filepath: string;
  oldString: string;
  newString: string;
}

export interface RunHTTPRequest {
  method: string;
  path: string;
  body?: string | undefined;
}

export interface RunGitCommand {
  command: string;
  arguments?: string | undefined;
  repositoryUrl: string;
}

export interface GenerateTokenRequest {
}

export interface GenerateTokenResponse {
  token: string;
  expiresAt: number;
}

export interface ContextElement {
  type: ContextElementType;
  name: string;
  contents: string;
}

export interface NewCheckpoint {
  status: string;
  checkpoint: string;
  goal: string;
  errors: string[];
}

export interface ListDirectory {
  directory: string;
}

export interface Grep {
  searchDirectory: string;
  pattern: string;
  caseInsensitive: boolean;
}

export interface FindFiles {
  namePattern: string;
}

export interface McpTool {
  name: string;
  description: string;
  inputSchema: string;
}

export interface RunMCPTool {
  name: string;
  args: string;
}

export interface AdditionalContext {
  category: string;
  id?: string | undefined;
  content?: string | undefined;
  metadata?: string | undefined;
}

function createBaseClientEvent(): ClientEvent {
  return { startRequest: undefined, actionResponse: undefined };
}

export const ClientEvent: MessageFns<ClientEvent> = {
  encode(message: ClientEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startRequest !== undefined) {
      StartWorkflowRequest.encode(message.startRequest, writer.uint32(10).fork()).join();
    }
    if (message.actionResponse !== undefined) {
      ActionResponse.encode(message.actionResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startRequest = StartWorkflowRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actionResponse = ActionResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent {
    return {
      startRequest: isSet(object.startRequest) ? StartWorkflowRequest.fromJSON(object.startRequest) : undefined,
      actionResponse: isSet(object.actionResponse) ? ActionResponse.fromJSON(object.actionResponse) : undefined,
    };
  },

  toJSON(message: ClientEvent): unknown {
    const obj: any = {};
    if (message.startRequest !== undefined) {
      obj.startRequest = StartWorkflowRequest.toJSON(message.startRequest);
    }
    if (message.actionResponse !== undefined) {
      obj.actionResponse = ActionResponse.toJSON(message.actionResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent>, I>>(base?: I): ClientEvent {
    return ClientEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent>, I>>(object: I): ClientEvent {
    const message = createBaseClientEvent();
    message.startRequest = (object.startRequest !== undefined && object.startRequest !== null)
      ? StartWorkflowRequest.fromPartial(object.startRequest)
      : undefined;
    message.actionResponse = (object.actionResponse !== undefined && object.actionResponse !== null)
      ? ActionResponse.fromPartial(object.actionResponse)
      : undefined;
    return message;
  },
};

function createBaseStartWorkflowRequest(): StartWorkflowRequest {
  return {
    clientVersion: "",
    workflowID: "",
    workflowDefinition: "",
    goal: "",
    workflowMetadata: "",
    clientCapabilities: [],
    context: [],
    mcpTools: [],
    additionalContext: [],
  };
}

export const StartWorkflowRequest: MessageFns<StartWorkflowRequest> = {
  encode(message: StartWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientVersion !== "") {
      writer.uint32(10).string(message.clientVersion);
    }
    if (message.workflowID !== "") {
      writer.uint32(18).string(message.workflowID);
    }
    if (message.workflowDefinition !== "") {
      writer.uint32(26).string(message.workflowDefinition);
    }
    if (message.goal !== "") {
      writer.uint32(34).string(message.goal);
    }
    if (message.workflowMetadata !== "") {
      writer.uint32(42).string(message.workflowMetadata);
    }
    for (const v of message.clientCapabilities) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.context) {
      ContextElement.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.mcpTools) {
      McpTool.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.additionalContext) {
      AdditionalContext.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowDefinition = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowMetadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientCapabilities.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.context.push(ContextElement.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mcpTools.push(McpTool.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.additionalContext.push(AdditionalContext.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowRequest {
    return {
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
      workflowDefinition: isSet(object.workflowDefinition) ? globalThis.String(object.workflowDefinition) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      workflowMetadata: isSet(object.workflowMetadata) ? globalThis.String(object.workflowMetadata) : "",
      clientCapabilities: globalThis.Array.isArray(object?.clientCapabilities)
        ? object.clientCapabilities.map((e: any) => globalThis.String(e))
        : [],
      context: globalThis.Array.isArray(object?.context)
        ? object.context.map((e: any) => ContextElement.fromJSON(e))
        : [],
      mcpTools: globalThis.Array.isArray(object?.mcpTools) ? object.mcpTools.map((e: any) => McpTool.fromJSON(e)) : [],
      additionalContext: globalThis.Array.isArray(object?.additionalContext)
        ? object.additionalContext.map((e: any) => AdditionalContext.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartWorkflowRequest): unknown {
    const obj: any = {};
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    if (message.workflowDefinition !== "") {
      obj.workflowDefinition = message.workflowDefinition;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.workflowMetadata !== "") {
      obj.workflowMetadata = message.workflowMetadata;
    }
    if (message.clientCapabilities?.length) {
      obj.clientCapabilities = message.clientCapabilities;
    }
    if (message.context?.length) {
      obj.context = message.context.map((e) => ContextElement.toJSON(e));
    }
    if (message.mcpTools?.length) {
      obj.mcpTools = message.mcpTools.map((e) => McpTool.toJSON(e));
    }
    if (message.additionalContext?.length) {
      obj.additionalContext = message.additionalContext.map((e) => AdditionalContext.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(base?: I): StartWorkflowRequest {
    return StartWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(object: I): StartWorkflowRequest {
    const message = createBaseStartWorkflowRequest();
    message.clientVersion = object.clientVersion ?? "";
    message.workflowID = object.workflowID ?? "";
    message.workflowDefinition = object.workflowDefinition ?? "";
    message.goal = object.goal ?? "";
    message.workflowMetadata = object.workflowMetadata ?? "";
    message.clientCapabilities = object.clientCapabilities?.map((e) => e) || [];
    message.context = object.context?.map((e) => ContextElement.fromPartial(e)) || [];
    message.mcpTools = object.mcpTools?.map((e) => McpTool.fromPartial(e)) || [];
    message.additionalContext = object.additionalContext?.map((e) => AdditionalContext.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActionResponse(): ActionResponse {
  return { requestID: "", response: "", plainTextResponse: undefined, httpResponse: undefined };
}

export const ActionResponse: MessageFns<ActionResponse> = {
  encode(message: ActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.response !== "") {
      writer.uint32(18).string(message.response);
    }
    if (message.plainTextResponse !== undefined) {
      PlainTextResponse.encode(message.plainTextResponse, writer.uint32(26).fork()).join();
    }
    if (message.httpResponse !== undefined) {
      HttpResponse.encode(message.httpResponse, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.plainTextResponse = PlainTextResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.httpResponse = HttpResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      plainTextResponse: isSet(object.plainTextResponse)
        ? PlainTextResponse.fromJSON(object.plainTextResponse)
        : undefined,
      httpResponse: isSet(object.httpResponse) ? HttpResponse.fromJSON(object.httpResponse) : undefined,
    };
  },

  toJSON(message: ActionResponse): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.plainTextResponse !== undefined) {
      obj.plainTextResponse = PlainTextResponse.toJSON(message.plainTextResponse);
    }
    if (message.httpResponse !== undefined) {
      obj.httpResponse = HttpResponse.toJSON(message.httpResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionResponse>, I>>(base?: I): ActionResponse {
    return ActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionResponse>, I>>(object: I): ActionResponse {
    const message = createBaseActionResponse();
    message.requestID = object.requestID ?? "";
    message.response = object.response ?? "";
    message.plainTextResponse = (object.plainTextResponse !== undefined && object.plainTextResponse !== null)
      ? PlainTextResponse.fromPartial(object.plainTextResponse)
      : undefined;
    message.httpResponse = (object.httpResponse !== undefined && object.httpResponse !== null)
      ? HttpResponse.fromPartial(object.httpResponse)
      : undefined;
    return message;
  },
};

function createBasePlainTextResponse(): PlainTextResponse {
  return { response: "", error: "" };
}

export const PlainTextResponse: MessageFns<PlainTextResponse> = {
  encode(message: PlainTextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlainTextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlainTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlainTextResponse {
    return {
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: PlainTextResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlainTextResponse>, I>>(base?: I): PlainTextResponse {
    return PlainTextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlainTextResponse>, I>>(object: I): PlainTextResponse {
    const message = createBasePlainTextResponse();
    message.response = object.response ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseHttpResponse(): HttpResponse {
  return { headers: {}, statusCode: 0, body: "", error: "" };
}

export const HttpResponse: MessageFns<HttpResponse> = {
  encode(message: HttpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.headers).forEach(([key, value]) => {
      HttpResponse_HeadersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.statusCode !== 0) {
      writer.uint32(16).int32(message.statusCode);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = HttpResponse_HeadersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.headers[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpResponse {
    return {
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: HttpResponse): unknown {
    const obj: any = {};
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpResponse>, I>>(base?: I): HttpResponse {
    return HttpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpResponse>, I>>(object: I): HttpResponse {
    const message = createBaseHttpResponse();
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.statusCode = object.statusCode ?? 0;
    message.body = object.body ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseHttpResponse_HeadersEntry(): HttpResponse_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpResponse_HeadersEntry: MessageFns<HttpResponse_HeadersEntry> = {
  encode(message: HttpResponse_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpResponse_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpResponse_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpResponse_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpResponse_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpResponse_HeadersEntry>, I>>(base?: I): HttpResponse_HeadersEntry {
    return HttpResponse_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpResponse_HeadersEntry>, I>>(object: I): HttpResponse_HeadersEntry {
    const message = createBaseHttpResponse_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAction(): Action {
  return {
    requestID: "",
    runCommand: undefined,
    runHTTPRequest: undefined,
    runReadFile: undefined,
    runWriteFile: undefined,
    runGitCommand: undefined,
    runEditFile: undefined,
    newCheckpoint: undefined,
    listDirectory: undefined,
    grep: undefined,
    findFiles: undefined,
    runMCPTool: undefined,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.runCommand !== undefined) {
      RunCommandAction.encode(message.runCommand, writer.uint32(18).fork()).join();
    }
    if (message.runHTTPRequest !== undefined) {
      RunHTTPRequest.encode(message.runHTTPRequest, writer.uint32(26).fork()).join();
    }
    if (message.runReadFile !== undefined) {
      ReadFile.encode(message.runReadFile, writer.uint32(34).fork()).join();
    }
    if (message.runWriteFile !== undefined) {
      WriteFile.encode(message.runWriteFile, writer.uint32(42).fork()).join();
    }
    if (message.runGitCommand !== undefined) {
      RunGitCommand.encode(message.runGitCommand, writer.uint32(50).fork()).join();
    }
    if (message.runEditFile !== undefined) {
      EditFile.encode(message.runEditFile, writer.uint32(58).fork()).join();
    }
    if (message.newCheckpoint !== undefined) {
      NewCheckpoint.encode(message.newCheckpoint, writer.uint32(66).fork()).join();
    }
    if (message.listDirectory !== undefined) {
      ListDirectory.encode(message.listDirectory, writer.uint32(74).fork()).join();
    }
    if (message.grep !== undefined) {
      Grep.encode(message.grep, writer.uint32(82).fork()).join();
    }
    if (message.findFiles !== undefined) {
      FindFiles.encode(message.findFiles, writer.uint32(90).fork()).join();
    }
    if (message.runMCPTool !== undefined) {
      RunMCPTool.encode(message.runMCPTool, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runCommand = RunCommandAction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runHTTPRequest = RunHTTPRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runReadFile = ReadFile.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runWriteFile = WriteFile.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.runGitCommand = RunGitCommand.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.runEditFile = EditFile.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.newCheckpoint = NewCheckpoint.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.listDirectory = ListDirectory.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.grep = Grep.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.findFiles = FindFiles.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.runMCPTool = RunMCPTool.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      runCommand: isSet(object.runCommand) ? RunCommandAction.fromJSON(object.runCommand) : undefined,
      runHTTPRequest: isSet(object.runHTTPRequest) ? RunHTTPRequest.fromJSON(object.runHTTPRequest) : undefined,
      runReadFile: isSet(object.runReadFile) ? ReadFile.fromJSON(object.runReadFile) : undefined,
      runWriteFile: isSet(object.runWriteFile) ? WriteFile.fromJSON(object.runWriteFile) : undefined,
      runGitCommand: isSet(object.runGitCommand) ? RunGitCommand.fromJSON(object.runGitCommand) : undefined,
      runEditFile: isSet(object.runEditFile) ? EditFile.fromJSON(object.runEditFile) : undefined,
      newCheckpoint: isSet(object.newCheckpoint) ? NewCheckpoint.fromJSON(object.newCheckpoint) : undefined,
      listDirectory: isSet(object.listDirectory) ? ListDirectory.fromJSON(object.listDirectory) : undefined,
      grep: isSet(object.grep) ? Grep.fromJSON(object.grep) : undefined,
      findFiles: isSet(object.findFiles) ? FindFiles.fromJSON(object.findFiles) : undefined,
      runMCPTool: isSet(object.runMCPTool) ? RunMCPTool.fromJSON(object.runMCPTool) : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.runCommand !== undefined) {
      obj.runCommand = RunCommandAction.toJSON(message.runCommand);
    }
    if (message.runHTTPRequest !== undefined) {
      obj.runHTTPRequest = RunHTTPRequest.toJSON(message.runHTTPRequest);
    }
    if (message.runReadFile !== undefined) {
      obj.runReadFile = ReadFile.toJSON(message.runReadFile);
    }
    if (message.runWriteFile !== undefined) {
      obj.runWriteFile = WriteFile.toJSON(message.runWriteFile);
    }
    if (message.runGitCommand !== undefined) {
      obj.runGitCommand = RunGitCommand.toJSON(message.runGitCommand);
    }
    if (message.runEditFile !== undefined) {
      obj.runEditFile = EditFile.toJSON(message.runEditFile);
    }
    if (message.newCheckpoint !== undefined) {
      obj.newCheckpoint = NewCheckpoint.toJSON(message.newCheckpoint);
    }
    if (message.listDirectory !== undefined) {
      obj.listDirectory = ListDirectory.toJSON(message.listDirectory);
    }
    if (message.grep !== undefined) {
      obj.grep = Grep.toJSON(message.grep);
    }
    if (message.findFiles !== undefined) {
      obj.findFiles = FindFiles.toJSON(message.findFiles);
    }
    if (message.runMCPTool !== undefined) {
      obj.runMCPTool = RunMCPTool.toJSON(message.runMCPTool);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.requestID = object.requestID ?? "";
    message.runCommand = (object.runCommand !== undefined && object.runCommand !== null)
      ? RunCommandAction.fromPartial(object.runCommand)
      : undefined;
    message.runHTTPRequest = (object.runHTTPRequest !== undefined && object.runHTTPRequest !== null)
      ? RunHTTPRequest.fromPartial(object.runHTTPRequest)
      : undefined;
    message.runReadFile = (object.runReadFile !== undefined && object.runReadFile !== null)
      ? ReadFile.fromPartial(object.runReadFile)
      : undefined;
    message.runWriteFile = (object.runWriteFile !== undefined && object.runWriteFile !== null)
      ? WriteFile.fromPartial(object.runWriteFile)
      : undefined;
    message.runGitCommand = (object.runGitCommand !== undefined && object.runGitCommand !== null)
      ? RunGitCommand.fromPartial(object.runGitCommand)
      : undefined;
    message.runEditFile = (object.runEditFile !== undefined && object.runEditFile !== null)
      ? EditFile.fromPartial(object.runEditFile)
      : undefined;
    message.newCheckpoint = (object.newCheckpoint !== undefined && object.newCheckpoint !== null)
      ? NewCheckpoint.fromPartial(object.newCheckpoint)
      : undefined;
    message.listDirectory = (object.listDirectory !== undefined && object.listDirectory !== null)
      ? ListDirectory.fromPartial(object.listDirectory)
      : undefined;
    message.grep = (object.grep !== undefined && object.grep !== null) ? Grep.fromPartial(object.grep) : undefined;
    message.findFiles = (object.findFiles !== undefined && object.findFiles !== null)
      ? FindFiles.fromPartial(object.findFiles)
      : undefined;
    message.runMCPTool = (object.runMCPTool !== undefined && object.runMCPTool !== null)
      ? RunMCPTool.fromPartial(object.runMCPTool)
      : undefined;
    return message;
  },
};

function createBaseRunCommandAction(): RunCommandAction {
  return { program: "", arguments: [], flags: [] };
}

export const RunCommandAction: MessageFns<RunCommandAction> = {
  encode(message: RunCommandAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== "") {
      writer.uint32(26).string(message.program);
    }
    for (const v of message.arguments) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.flags) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunCommandAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunCommandAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.program = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.flags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunCommandAction {
    return {
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RunCommandAction): unknown {
    const obj: any = {};
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunCommandAction>, I>>(base?: I): RunCommandAction {
    return RunCommandAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunCommandAction>, I>>(object: I): RunCommandAction {
    const message = createBaseRunCommandAction();
    message.program = object.program ?? "";
    message.arguments = object.arguments?.map((e) => e) || [];
    message.flags = object.flags?.map((e) => e) || [];
    return message;
  },
};

function createBaseReadFile(): ReadFile {
  return { filepath: "" };
}

export const ReadFile: MessageFns<ReadFile> = {
  encode(message: ReadFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFile {
    return { filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "" };
  },

  toJSON(message: ReadFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFile>, I>>(base?: I): ReadFile {
    return ReadFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFile>, I>>(object: I): ReadFile {
    const message = createBaseReadFile();
    message.filepath = object.filepath ?? "";
    return message;
  },
};

function createBaseWriteFile(): WriteFile {
  return { filepath: "", contents: "" };
}

export const WriteFile: MessageFns<WriteFile> = {
  encode(message: WriteFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.contents !== "") {
      writer.uint32(18).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: WriteFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFile>, I>>(base?: I): WriteFile {
    return WriteFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFile>, I>>(object: I): WriteFile {
    const message = createBaseWriteFile();
    message.filepath = object.filepath ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseEditFile(): EditFile {
  return { filepath: "", oldString: "", newString: "" };
}

export const EditFile: MessageFns<EditFile> = {
  encode(message: EditFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.oldString !== "") {
      writer.uint32(18).string(message.oldString);
    }
    if (message.newString !== "") {
      writer.uint32(26).string(message.newString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldString = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      oldString: isSet(object.oldString) ? globalThis.String(object.oldString) : "",
      newString: isSet(object.newString) ? globalThis.String(object.newString) : "",
    };
  },

  toJSON(message: EditFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.oldString !== "") {
      obj.oldString = message.oldString;
    }
    if (message.newString !== "") {
      obj.newString = message.newString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditFile>, I>>(base?: I): EditFile {
    return EditFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditFile>, I>>(object: I): EditFile {
    const message = createBaseEditFile();
    message.filepath = object.filepath ?? "";
    message.oldString = object.oldString ?? "";
    message.newString = object.newString ?? "";
    return message;
  },
};

function createBaseRunHTTPRequest(): RunHTTPRequest {
  return { method: "", path: "", body: undefined };
}

export const RunHTTPRequest: MessageFns<RunHTTPRequest> = {
  encode(message: RunHTTPRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.body !== undefined) {
      writer.uint32(26).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunHTTPRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunHTTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunHTTPRequest {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : undefined,
    };
  },

  toJSON(message: RunHTTPRequest): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(base?: I): RunHTTPRequest {
    return RunHTTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(object: I): RunHTTPRequest {
    const message = createBaseRunHTTPRequest();
    message.method = object.method ?? "";
    message.path = object.path ?? "";
    message.body = object.body ?? undefined;
    return message;
  },
};

function createBaseRunGitCommand(): RunGitCommand {
  return { command: "", arguments: undefined, repositoryUrl: "" };
}

export const RunGitCommand: MessageFns<RunGitCommand> = {
  encode(message: RunGitCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.arguments !== undefined) {
      writer.uint32(18).string(message.arguments);
    }
    if (message.repositoryUrl !== "") {
      writer.uint32(26).string(message.repositoryUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunGitCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunGitCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repositoryUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunGitCommand {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : undefined,
      repositoryUrl: isSet(object.repositoryUrl) ? globalThis.String(object.repositoryUrl) : "",
    };
  },

  toJSON(message: RunGitCommand): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.arguments !== undefined) {
      obj.arguments = message.arguments;
    }
    if (message.repositoryUrl !== "") {
      obj.repositoryUrl = message.repositoryUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunGitCommand>, I>>(base?: I): RunGitCommand {
    return RunGitCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunGitCommand>, I>>(object: I): RunGitCommand {
    const message = createBaseRunGitCommand();
    message.command = object.command ?? "";
    message.arguments = object.arguments ?? undefined;
    message.repositoryUrl = object.repositoryUrl ?? "";
    return message;
  },
};

function createBaseGenerateTokenRequest(): GenerateTokenRequest {
  return {};
}

export const GenerateTokenRequest: MessageFns<GenerateTokenRequest> = {
  encode(_: GenerateTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerateTokenRequest {
    return {};
  },

  toJSON(_: GenerateTokenRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(base?: I): GenerateTokenRequest {
    return GenerateTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(_: I): GenerateTokenRequest {
    const message = createBaseGenerateTokenRequest();
    return message;
  },
};

function createBaseGenerateTokenResponse(): GenerateTokenResponse {
  return { token: "", expiresAt: 0 };
}

export const GenerateTokenResponse: MessageFns<GenerateTokenResponse> = {
  encode(message: GenerateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTokenResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
    };
  },

  toJSON(message: GenerateTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(base?: I): GenerateTokenResponse {
    return GenerateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(object: I): GenerateTokenResponse {
    const message = createBaseGenerateTokenResponse();
    message.token = object.token ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function createBaseContextElement(): ContextElement {
  return { type: 0, name: "", contents: "" };
}

export const ContextElement: MessageFns<ContextElement> = {
  encode(message: ContextElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.contents !== "") {
      writer.uint32(26).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContextElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextElement {
    return {
      type: isSet(object.type) ? contextElementTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: ContextElement): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = contextElementTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextElement>, I>>(base?: I): ContextElement {
    return ContextElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextElement>, I>>(object: I): ContextElement {
    const message = createBaseContextElement();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseNewCheckpoint(): NewCheckpoint {
  return { status: "", checkpoint: "", goal: "", errors: [] };
}

export const NewCheckpoint: MessageFns<NewCheckpoint> = {
  encode(message: NewCheckpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.checkpoint !== "") {
      writer.uint32(18).string(message.checkpoint);
    }
    if (message.goal !== "") {
      writer.uint32(26).string(message.goal);
    }
    for (const v of message.errors) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewCheckpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewCheckpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewCheckpoint {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      checkpoint: isSet(object.checkpoint) ? globalThis.String(object.checkpoint) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NewCheckpoint): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.checkpoint !== "") {
      obj.checkpoint = message.checkpoint;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewCheckpoint>, I>>(base?: I): NewCheckpoint {
    return NewCheckpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewCheckpoint>, I>>(object: I): NewCheckpoint {
    const message = createBaseNewCheckpoint();
    message.status = object.status ?? "";
    message.checkpoint = object.checkpoint ?? "";
    message.goal = object.goal ?? "";
    message.errors = object.errors?.map((e) => e) || [];
    return message;
  },
};

function createBaseListDirectory(): ListDirectory {
  return { directory: "" };
}

export const ListDirectory: MessageFns<ListDirectory> = {
  encode(message: ListDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directory !== "") {
      writer.uint32(10).string(message.directory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.directory = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDirectory {
    return { directory: isSet(object.directory) ? globalThis.String(object.directory) : "" };
  },

  toJSON(message: ListDirectory): unknown {
    const obj: any = {};
    if (message.directory !== "") {
      obj.directory = message.directory;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDirectory>, I>>(base?: I): ListDirectory {
    return ListDirectory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDirectory>, I>>(object: I): ListDirectory {
    const message = createBaseListDirectory();
    message.directory = object.directory ?? "";
    return message;
  },
};

function createBaseGrep(): Grep {
  return { searchDirectory: "", pattern: "", caseInsensitive: false };
}

export const Grep: MessageFns<Grep> = {
  encode(message: Grep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchDirectory !== "") {
      writer.uint32(10).string(message.searchDirectory);
    }
    if (message.pattern !== "") {
      writer.uint32(18).string(message.pattern);
    }
    if (message.caseInsensitive !== false) {
      writer.uint32(24).bool(message.caseInsensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Grep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchDirectory = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.caseInsensitive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Grep {
    return {
      searchDirectory: isSet(object.searchDirectory) ? globalThis.String(object.searchDirectory) : "",
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      caseInsensitive: isSet(object.caseInsensitive) ? globalThis.Boolean(object.caseInsensitive) : false,
    };
  },

  toJSON(message: Grep): unknown {
    const obj: any = {};
    if (message.searchDirectory !== "") {
      obj.searchDirectory = message.searchDirectory;
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.caseInsensitive !== false) {
      obj.caseInsensitive = message.caseInsensitive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Grep>, I>>(base?: I): Grep {
    return Grep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Grep>, I>>(object: I): Grep {
    const message = createBaseGrep();
    message.searchDirectory = object.searchDirectory ?? "";
    message.pattern = object.pattern ?? "";
    message.caseInsensitive = object.caseInsensitive ?? false;
    return message;
  },
};

function createBaseFindFiles(): FindFiles {
  return { namePattern: "" };
}

export const FindFiles: MessageFns<FindFiles> = {
  encode(message: FindFiles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namePattern !== "") {
      writer.uint32(10).string(message.namePattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindFiles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namePattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindFiles {
    return { namePattern: isSet(object.namePattern) ? globalThis.String(object.namePattern) : "" };
  },

  toJSON(message: FindFiles): unknown {
    const obj: any = {};
    if (message.namePattern !== "") {
      obj.namePattern = message.namePattern;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindFiles>, I>>(base?: I): FindFiles {
    return FindFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindFiles>, I>>(object: I): FindFiles {
    const message = createBaseFindFiles();
    message.namePattern = object.namePattern ?? "";
    return message;
  },
};

function createBaseMcpTool(): McpTool {
  return { name: "", description: "", inputSchema: "" };
}

export const McpTool: MessageFns<McpTool> = {
  encode(message: McpTool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.inputSchema !== "") {
      writer.uint32(26).string(message.inputSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpTool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpTool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      inputSchema: isSet(object.inputSchema) ? globalThis.String(object.inputSchema) : "",
    };
  },

  toJSON(message: McpTool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.inputSchema !== "") {
      obj.inputSchema = message.inputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpTool>, I>>(base?: I): McpTool {
    return McpTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpTool>, I>>(object: I): McpTool {
    const message = createBaseMcpTool();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.inputSchema = object.inputSchema ?? "";
    return message;
  },
};

function createBaseRunMCPTool(): RunMCPTool {
  return { name: "", args: "" };
}

export const RunMCPTool: MessageFns<RunMCPTool> = {
  encode(message: RunMCPTool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.args !== "") {
      writer.uint32(18).string(message.args);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunMCPTool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunMCPTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunMCPTool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      args: isSet(object.args) ? globalThis.String(object.args) : "",
    };
  },

  toJSON(message: RunMCPTool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.args !== "") {
      obj.args = message.args;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunMCPTool>, I>>(base?: I): RunMCPTool {
    return RunMCPTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunMCPTool>, I>>(object: I): RunMCPTool {
    const message = createBaseRunMCPTool();
    message.name = object.name ?? "";
    message.args = object.args ?? "";
    return message;
  },
};

function createBaseAdditionalContext(): AdditionalContext {
  return { category: "", id: undefined, content: undefined, metadata: undefined };
}

export const AdditionalContext: MessageFns<AdditionalContext> = {
  encode(message: AdditionalContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    if (message.content !== undefined) {
      writer.uint32(26).string(message.content);
    }
    if (message.metadata !== undefined) {
      writer.uint32(34).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdditionalContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalContext {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      content: isSet(object.content) ? globalThis.String(object.content) : undefined,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : undefined,
    };
  },

  toJSON(message: AdditionalContext): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdditionalContext>, I>>(base?: I): AdditionalContext {
    return AdditionalContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdditionalContext>, I>>(object: I): AdditionalContext {
    const message = createBaseAdditionalContext();
    message.category = object.category ?? "";
    message.id = object.id ?? undefined;
    message.content = object.content ?? undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

export type DuoWorkflowService = typeof DuoWorkflowService;
export const DuoWorkflowService = {
  executeWorkflow: {
    path: "/DuoWorkflow/ExecuteWorkflow",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ClientEvent) => Buffer.from(ClientEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClientEvent.decode(value),
    responseSerialize: (value: Action) => Buffer.from(Action.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Action.decode(value),
  },
  generateToken: {
    path: "/DuoWorkflow/GenerateToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateTokenRequest) => Buffer.from(GenerateTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GenerateTokenRequest.decode(value),
    responseSerialize: (value: GenerateTokenResponse) => Buffer.from(GenerateTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GenerateTokenResponse.decode(value),
  },
} as const;

export interface DuoWorkflowServer extends UntypedServiceImplementation {
  executeWorkflow: handleBidiStreamingCall<ClientEvent, Action>;
  generateToken: handleUnaryCall<GenerateTokenRequest, GenerateTokenResponse>;
}

export interface DuoWorkflowClient extends Client {
  executeWorkflow(): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(options: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  generateToken(
    request: GenerateTokenRequest,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
}

export const DuoWorkflowClient = makeGenericClientConstructor(DuoWorkflowService, "DuoWorkflow") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DuoWorkflowClient;
  service: typeof DuoWorkflowService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
