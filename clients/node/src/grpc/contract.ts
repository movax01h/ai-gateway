// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.27.3
// source: contract.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Struct } from "./google/protobuf/struct";

export const protobufPackage = "";

export interface ClientEvent {
  startRequest?: StartWorkflowRequest | undefined;
  actionResponse?: ActionResponse | undefined;
  heartbeat?: HeartbeatRequest | undefined;
  stopWorkflow?: StopWorkflowRequest | undefined;
}

export interface StartWorkflowRequest {
  clientVersion: string;
  workflowID: string;
  workflowDefinition: string;
  goal: string;
  workflowMetadata: string;
  clientCapabilities: string[];
  mcpTools: McpTool[];
  additional_context: AdditionalContext[];
  approval?: Approval | undefined;
  flowConfig?: { [key: string]: any } | undefined;
  flowConfigSchemaVersion?: string | undefined;
  preapproved_tools: string[];
}

export interface ActionResponse {
  requestID: string;
  response?: string | undefined;
  plainTextResponse?: PlainTextResponse | undefined;
  httpResponse?: HttpResponse | undefined;
}

export interface HeartbeatRequest {
  timestamp: number;
}

export interface StopWorkflowRequest {
  reason: string;
}

export interface PlainTextResponse {
  response: string;
  error: string;
}

export interface HttpResponse {
  headers: { [key: string]: string };
  statusCode: number;
  body: string;
  error: string;
}

export interface HttpResponse_HeadersEntry {
  key: string;
  value: string;
}

export interface Action {
  requestID: string;
  runCommand?: RunCommandAction | undefined;
  runHTTPRequest?: RunHTTPRequest | undefined;
  runReadFile?: ReadFile | undefined;
  runWriteFile?: WriteFile | undefined;
  runGitCommand?: RunGitCommand | undefined;
  runEditFile?: EditFile | undefined;
  newCheckpoint?: NewCheckpoint | undefined;
  listDirectory?: ListDirectory | undefined;
  grep?: Grep | undefined;
  findFiles?: FindFiles | undefined;
  runMCPTool?: RunMCPTool | undefined;
  mkdir?: Mkdir | undefined;
  runReadFiles?: ReadFiles | undefined;
  runShellCommand?: RunShellCommand | undefined;
  trackLlmCallForSelfHosted?: TrackLlmCallForSelfHosted | undefined;
}

export interface TrackLlmCallForSelfHosted {
  workflowID: string;
  featureQualifiedName: string;
  featureAiCatalogItem: boolean;
}

export interface RunShellCommand {
  command: string;
}

export interface RunCommandAction {
  program: string;
  arguments: string[];
  flags: string[];
}

export interface ReadFile {
  filepath: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface ReadFiles {
  filepaths: string[];
}

export interface WriteFile {
  filepath: string;
  contents: string;
}

export interface EditFile {
  filepath: string;
  oldString: string;
  newString: string;
}

export interface RunHTTPRequest {
  method: string;
  path: string;
  body?: string | undefined;
}

export interface RunGitCommand {
  command: string;
  arguments?: string | undefined;
  repository_url: string;
}

export interface GenerateTokenRequest {
  workflowDefinition?: string | undefined;
}

export interface GenerateTokenResponse {
  token: string;
  expiresAt: number;
}

/** Intentionally empty */
export interface ListToolsRequest {
}

export interface ListToolsResponse {
  tools: { [key: string]: any }[];
  eval_dataset: { [key: string]: any }[];
}

export interface ListFlowsRequest {
  filters?: ListFlowsRequestFilter | undefined;
}

export interface ListFlowsRequestFilter {
  flow_identifier: string[];
  environment: string[];
  version: string[];
}

export interface ListFlowsResponse {
  configs: { [key: string]: any }[];
}

export interface NewCheckpoint {
  status: string;
  checkpoint: string;
  goal: string;
  errors: string[];
}

export interface ListDirectory {
  directory: string;
}

export interface Grep {
  search_directory: string;
  pattern: string;
  case_insensitive: boolean;
}

export interface FindFiles {
  name_pattern: string;
}

export interface McpTool {
  name: string;
  description: string;
  inputSchema: string;
}

export interface RunMCPTool {
  name: string;
  args: string;
}

export interface AdditionalContext {
  category: string;
  id?: string | undefined;
  content?: string | undefined;
  metadata?: string | undefined;
}

export interface Approval {
  approval?: Approval_Approved | undefined;
  rejection?: Approval_Rejected | undefined;
}

export interface Approval_Approved {
  remember_approval?: boolean | undefined;
  tool_name?: string | undefined;
  tool_args_json?: string | undefined;
}

export interface Approval_Rejected {
  message?: string | undefined;
}

export interface Mkdir {
  directory_path: string;
}

export interface OsInformationContext {
  platform: string;
  architecture: string;
}

export interface ShellInformationContext {
  shell_name: string;
  shell_type: string;
  shell_variant?: string | undefined;
  shell_environment?: string | undefined;
  ssh_session?: boolean | undefined;
  cwd?: string | undefined;
}

export interface TrackSelfHostedClientEvent {
  requestID: string;
  workflowID: string;
  featureQualifiedName: string;
  featureAiCatalogItem: boolean;
}

export interface TrackSelfHostedAction {
  requestID: string;
}

function createBaseClientEvent(): ClientEvent {
  return { startRequest: undefined, actionResponse: undefined, heartbeat: undefined, stopWorkflow: undefined };
}

export const ClientEvent: MessageFns<ClientEvent> = {
  encode(message: ClientEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startRequest !== undefined) {
      StartWorkflowRequest.encode(message.startRequest, writer.uint32(10).fork()).join();
    }
    if (message.actionResponse !== undefined) {
      ActionResponse.encode(message.actionResponse, writer.uint32(18).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      HeartbeatRequest.encode(message.heartbeat, writer.uint32(26).fork()).join();
    }
    if (message.stopWorkflow !== undefined) {
      StopWorkflowRequest.encode(message.stopWorkflow, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startRequest = StartWorkflowRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actionResponse = ActionResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.heartbeat = HeartbeatRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stopWorkflow = StopWorkflowRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent {
    return {
      startRequest: isSet(object.startRequest) ? StartWorkflowRequest.fromJSON(object.startRequest) : undefined,
      actionResponse: isSet(object.actionResponse) ? ActionResponse.fromJSON(object.actionResponse) : undefined,
      heartbeat: isSet(object.heartbeat) ? HeartbeatRequest.fromJSON(object.heartbeat) : undefined,
      stopWorkflow: isSet(object.stopWorkflow) ? StopWorkflowRequest.fromJSON(object.stopWorkflow) : undefined,
    };
  },

  toJSON(message: ClientEvent): unknown {
    const obj: any = {};
    if (message.startRequest !== undefined) {
      obj.startRequest = StartWorkflowRequest.toJSON(message.startRequest);
    }
    if (message.actionResponse !== undefined) {
      obj.actionResponse = ActionResponse.toJSON(message.actionResponse);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = HeartbeatRequest.toJSON(message.heartbeat);
    }
    if (message.stopWorkflow !== undefined) {
      obj.stopWorkflow = StopWorkflowRequest.toJSON(message.stopWorkflow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent>, I>>(base?: I): ClientEvent {
    return ClientEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent>, I>>(object: I): ClientEvent {
    const message = createBaseClientEvent();
    message.startRequest = (object.startRequest !== undefined && object.startRequest !== null)
      ? StartWorkflowRequest.fromPartial(object.startRequest)
      : undefined;
    message.actionResponse = (object.actionResponse !== undefined && object.actionResponse !== null)
      ? ActionResponse.fromPartial(object.actionResponse)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? HeartbeatRequest.fromPartial(object.heartbeat)
      : undefined;
    message.stopWorkflow = (object.stopWorkflow !== undefined && object.stopWorkflow !== null)
      ? StopWorkflowRequest.fromPartial(object.stopWorkflow)
      : undefined;
    return message;
  },
};

function createBaseStartWorkflowRequest(): StartWorkflowRequest {
  return {
    clientVersion: "",
    workflowID: "",
    workflowDefinition: "",
    goal: "",
    workflowMetadata: "",
    clientCapabilities: [],
    mcpTools: [],
    additional_context: [],
    approval: undefined,
    flowConfig: undefined,
    flowConfigSchemaVersion: undefined,
    preapproved_tools: [],
  };
}

export const StartWorkflowRequest: MessageFns<StartWorkflowRequest> = {
  encode(message: StartWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientVersion !== "") {
      writer.uint32(10).string(message.clientVersion);
    }
    if (message.workflowID !== "") {
      writer.uint32(18).string(message.workflowID);
    }
    if (message.workflowDefinition !== "") {
      writer.uint32(26).string(message.workflowDefinition);
    }
    if (message.goal !== "") {
      writer.uint32(34).string(message.goal);
    }
    if (message.workflowMetadata !== "") {
      writer.uint32(42).string(message.workflowMetadata);
    }
    for (const v of message.clientCapabilities) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.mcpTools) {
      McpTool.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.additional_context) {
      AdditionalContext.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.approval !== undefined) {
      Approval.encode(message.approval, writer.uint32(82).fork()).join();
    }
    if (message.flowConfig !== undefined) {
      Struct.encode(Struct.wrap(message.flowConfig), writer.uint32(90).fork()).join();
    }
    if (message.flowConfigSchemaVersion !== undefined) {
      writer.uint32(98).string(message.flowConfigSchemaVersion);
    }
    for (const v of message.preapproved_tools) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowDefinition = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workflowMetadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientCapabilities.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mcpTools.push(McpTool.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.additional_context.push(AdditionalContext.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.approval = Approval.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.flowConfig = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.flowConfigSchemaVersion = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.preapproved_tools.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowRequest {
    return {
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
      workflowDefinition: isSet(object.workflowDefinition) ? globalThis.String(object.workflowDefinition) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      workflowMetadata: isSet(object.workflowMetadata) ? globalThis.String(object.workflowMetadata) : "",
      clientCapabilities: globalThis.Array.isArray(object?.clientCapabilities)
        ? object.clientCapabilities.map((e: any) => globalThis.String(e))
        : [],
      mcpTools: globalThis.Array.isArray(object?.mcpTools) ? object.mcpTools.map((e: any) => McpTool.fromJSON(e)) : [],
      additional_context: globalThis.Array.isArray(object?.additional_context)
        ? object.additional_context.map((e: any) => AdditionalContext.fromJSON(e))
        : [],
      approval: isSet(object.approval) ? Approval.fromJSON(object.approval) : undefined,
      flowConfig: isObject(object.flowConfig) ? object.flowConfig : undefined,
      flowConfigSchemaVersion: isSet(object.flowConfigSchemaVersion)
        ? globalThis.String(object.flowConfigSchemaVersion)
        : undefined,
      preapproved_tools: globalThis.Array.isArray(object?.preapproved_tools)
        ? object.preapproved_tools.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StartWorkflowRequest): unknown {
    const obj: any = {};
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    if (message.workflowDefinition !== "") {
      obj.workflowDefinition = message.workflowDefinition;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.workflowMetadata !== "") {
      obj.workflowMetadata = message.workflowMetadata;
    }
    if (message.clientCapabilities?.length) {
      obj.clientCapabilities = message.clientCapabilities;
    }
    if (message.mcpTools?.length) {
      obj.mcpTools = message.mcpTools.map((e) => McpTool.toJSON(e));
    }
    if (message.additional_context?.length) {
      obj.additional_context = message.additional_context.map((e) => AdditionalContext.toJSON(e));
    }
    if (message.approval !== undefined) {
      obj.approval = Approval.toJSON(message.approval);
    }
    if (message.flowConfig !== undefined) {
      obj.flowConfig = message.flowConfig;
    }
    if (message.flowConfigSchemaVersion !== undefined) {
      obj.flowConfigSchemaVersion = message.flowConfigSchemaVersion;
    }
    if (message.preapproved_tools?.length) {
      obj.preapproved_tools = message.preapproved_tools;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(base?: I): StartWorkflowRequest {
    return StartWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartWorkflowRequest>, I>>(object: I): StartWorkflowRequest {
    const message = createBaseStartWorkflowRequest();
    message.clientVersion = object.clientVersion ?? "";
    message.workflowID = object.workflowID ?? "";
    message.workflowDefinition = object.workflowDefinition ?? "";
    message.goal = object.goal ?? "";
    message.workflowMetadata = object.workflowMetadata ?? "";
    message.clientCapabilities = object.clientCapabilities?.map((e) => e) || [];
    message.mcpTools = object.mcpTools?.map((e) => McpTool.fromPartial(e)) || [];
    message.additional_context = object.additional_context?.map((e) => AdditionalContext.fromPartial(e)) || [];
    message.approval = (object.approval !== undefined && object.approval !== null)
      ? Approval.fromPartial(object.approval)
      : undefined;
    message.flowConfig = object.flowConfig ?? undefined;
    message.flowConfigSchemaVersion = object.flowConfigSchemaVersion ?? undefined;
    message.preapproved_tools = object.preapproved_tools?.map((e) => e) || [];
    return message;
  },
};

function createBaseActionResponse(): ActionResponse {
  return { requestID: "", response: undefined, plainTextResponse: undefined, httpResponse: undefined };
}

export const ActionResponse: MessageFns<ActionResponse> = {
  encode(message: ActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.response !== undefined) {
      writer.uint32(18).string(message.response);
    }
    if (message.plainTextResponse !== undefined) {
      PlainTextResponse.encode(message.plainTextResponse, writer.uint32(26).fork()).join();
    }
    if (message.httpResponse !== undefined) {
      HttpResponse.encode(message.httpResponse, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.response = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.plainTextResponse = PlainTextResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.httpResponse = HttpResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      response: isSet(object.response) ? globalThis.String(object.response) : undefined,
      plainTextResponse: isSet(object.plainTextResponse)
        ? PlainTextResponse.fromJSON(object.plainTextResponse)
        : undefined,
      httpResponse: isSet(object.httpResponse) ? HttpResponse.fromJSON(object.httpResponse) : undefined,
    };
  },

  toJSON(message: ActionResponse): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.response !== undefined) {
      obj.response = message.response;
    }
    if (message.plainTextResponse !== undefined) {
      obj.plainTextResponse = PlainTextResponse.toJSON(message.plainTextResponse);
    }
    if (message.httpResponse !== undefined) {
      obj.httpResponse = HttpResponse.toJSON(message.httpResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionResponse>, I>>(base?: I): ActionResponse {
    return ActionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionResponse>, I>>(object: I): ActionResponse {
    const message = createBaseActionResponse();
    message.requestID = object.requestID ?? "";
    message.response = object.response ?? undefined;
    message.plainTextResponse = (object.plainTextResponse !== undefined && object.plainTextResponse !== null)
      ? PlainTextResponse.fromPartial(object.plainTextResponse)
      : undefined;
    message.httpResponse = (object.httpResponse !== undefined && object.httpResponse !== null)
      ? HttpResponse.fromPartial(object.httpResponse)
      : undefined;
    return message;
  },
};

function createBaseHeartbeatRequest(): HeartbeatRequest {
  return { timestamp: 0 };
}

export const HeartbeatRequest: MessageFns<HeartbeatRequest> = {
  encode(message: HeartbeatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatRequest {
    return { timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0 };
  },

  toJSON(message: HeartbeatRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(base?: I): HeartbeatRequest {
    return HeartbeatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(object: I): HeartbeatRequest {
    const message = createBaseHeartbeatRequest();
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseStopWorkflowRequest(): StopWorkflowRequest {
  return { reason: "" };
}

export const StopWorkflowRequest: MessageFns<StopWorkflowRequest> = {
  encode(message: StopWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopWorkflowRequest {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: StopWorkflowRequest): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopWorkflowRequest>, I>>(base?: I): StopWorkflowRequest {
    return StopWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopWorkflowRequest>, I>>(object: I): StopWorkflowRequest {
    const message = createBaseStopWorkflowRequest();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBasePlainTextResponse(): PlainTextResponse {
  return { response: "", error: "" };
}

export const PlainTextResponse: MessageFns<PlainTextResponse> = {
  encode(message: PlainTextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlainTextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlainTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlainTextResponse {
    return {
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: PlainTextResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlainTextResponse>, I>>(base?: I): PlainTextResponse {
    return PlainTextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlainTextResponse>, I>>(object: I): PlainTextResponse {
    const message = createBasePlainTextResponse();
    message.response = object.response ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseHttpResponse(): HttpResponse {
  return { headers: {}, statusCode: 0, body: "", error: "" };
}

export const HttpResponse: MessageFns<HttpResponse> = {
  encode(message: HttpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.headers).forEach(([key, value]) => {
      HttpResponse_HeadersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.statusCode !== 0) {
      writer.uint32(16).int32(message.statusCode);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = HttpResponse_HeadersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.headers[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpResponse {
    return {
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: HttpResponse): unknown {
    const obj: any = {};
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpResponse>, I>>(base?: I): HttpResponse {
    return HttpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpResponse>, I>>(object: I): HttpResponse {
    const message = createBaseHttpResponse();
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.statusCode = object.statusCode ?? 0;
    message.body = object.body ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseHttpResponse_HeadersEntry(): HttpResponse_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpResponse_HeadersEntry: MessageFns<HttpResponse_HeadersEntry> = {
  encode(message: HttpResponse_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpResponse_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpResponse_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpResponse_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpResponse_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpResponse_HeadersEntry>, I>>(base?: I): HttpResponse_HeadersEntry {
    return HttpResponse_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpResponse_HeadersEntry>, I>>(object: I): HttpResponse_HeadersEntry {
    const message = createBaseHttpResponse_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAction(): Action {
  return {
    requestID: "",
    runCommand: undefined,
    runHTTPRequest: undefined,
    runReadFile: undefined,
    runWriteFile: undefined,
    runGitCommand: undefined,
    runEditFile: undefined,
    newCheckpoint: undefined,
    listDirectory: undefined,
    grep: undefined,
    findFiles: undefined,
    runMCPTool: undefined,
    mkdir: undefined,
    runReadFiles: undefined,
    runShellCommand: undefined,
    trackLlmCallForSelfHosted: undefined,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.runCommand !== undefined) {
      RunCommandAction.encode(message.runCommand, writer.uint32(18).fork()).join();
    }
    if (message.runHTTPRequest !== undefined) {
      RunHTTPRequest.encode(message.runHTTPRequest, writer.uint32(26).fork()).join();
    }
    if (message.runReadFile !== undefined) {
      ReadFile.encode(message.runReadFile, writer.uint32(34).fork()).join();
    }
    if (message.runWriteFile !== undefined) {
      WriteFile.encode(message.runWriteFile, writer.uint32(42).fork()).join();
    }
    if (message.runGitCommand !== undefined) {
      RunGitCommand.encode(message.runGitCommand, writer.uint32(50).fork()).join();
    }
    if (message.runEditFile !== undefined) {
      EditFile.encode(message.runEditFile, writer.uint32(58).fork()).join();
    }
    if (message.newCheckpoint !== undefined) {
      NewCheckpoint.encode(message.newCheckpoint, writer.uint32(66).fork()).join();
    }
    if (message.listDirectory !== undefined) {
      ListDirectory.encode(message.listDirectory, writer.uint32(74).fork()).join();
    }
    if (message.grep !== undefined) {
      Grep.encode(message.grep, writer.uint32(82).fork()).join();
    }
    if (message.findFiles !== undefined) {
      FindFiles.encode(message.findFiles, writer.uint32(90).fork()).join();
    }
    if (message.runMCPTool !== undefined) {
      RunMCPTool.encode(message.runMCPTool, writer.uint32(98).fork()).join();
    }
    if (message.mkdir !== undefined) {
      Mkdir.encode(message.mkdir, writer.uint32(106).fork()).join();
    }
    if (message.runReadFiles !== undefined) {
      ReadFiles.encode(message.runReadFiles, writer.uint32(114).fork()).join();
    }
    if (message.runShellCommand !== undefined) {
      RunShellCommand.encode(message.runShellCommand, writer.uint32(122).fork()).join();
    }
    if (message.trackLlmCallForSelfHosted !== undefined) {
      TrackLlmCallForSelfHosted.encode(message.trackLlmCallForSelfHosted, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runCommand = RunCommandAction.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runHTTPRequest = RunHTTPRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runReadFile = ReadFile.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runWriteFile = WriteFile.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.runGitCommand = RunGitCommand.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.runEditFile = EditFile.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.newCheckpoint = NewCheckpoint.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.listDirectory = ListDirectory.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.grep = Grep.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.findFiles = FindFiles.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.runMCPTool = RunMCPTool.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.mkdir = Mkdir.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.runReadFiles = ReadFiles.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.runShellCommand = RunShellCommand.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.trackLlmCallForSelfHosted = TrackLlmCallForSelfHosted.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      runCommand: isSet(object.runCommand) ? RunCommandAction.fromJSON(object.runCommand) : undefined,
      runHTTPRequest: isSet(object.runHTTPRequest) ? RunHTTPRequest.fromJSON(object.runHTTPRequest) : undefined,
      runReadFile: isSet(object.runReadFile) ? ReadFile.fromJSON(object.runReadFile) : undefined,
      runWriteFile: isSet(object.runWriteFile) ? WriteFile.fromJSON(object.runWriteFile) : undefined,
      runGitCommand: isSet(object.runGitCommand) ? RunGitCommand.fromJSON(object.runGitCommand) : undefined,
      runEditFile: isSet(object.runEditFile) ? EditFile.fromJSON(object.runEditFile) : undefined,
      newCheckpoint: isSet(object.newCheckpoint) ? NewCheckpoint.fromJSON(object.newCheckpoint) : undefined,
      listDirectory: isSet(object.listDirectory) ? ListDirectory.fromJSON(object.listDirectory) : undefined,
      grep: isSet(object.grep) ? Grep.fromJSON(object.grep) : undefined,
      findFiles: isSet(object.findFiles) ? FindFiles.fromJSON(object.findFiles) : undefined,
      runMCPTool: isSet(object.runMCPTool) ? RunMCPTool.fromJSON(object.runMCPTool) : undefined,
      mkdir: isSet(object.mkdir) ? Mkdir.fromJSON(object.mkdir) : undefined,
      runReadFiles: isSet(object.runReadFiles) ? ReadFiles.fromJSON(object.runReadFiles) : undefined,
      runShellCommand: isSet(object.runShellCommand) ? RunShellCommand.fromJSON(object.runShellCommand) : undefined,
      trackLlmCallForSelfHosted: isSet(object.trackLlmCallForSelfHosted)
        ? TrackLlmCallForSelfHosted.fromJSON(object.trackLlmCallForSelfHosted)
        : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.runCommand !== undefined) {
      obj.runCommand = RunCommandAction.toJSON(message.runCommand);
    }
    if (message.runHTTPRequest !== undefined) {
      obj.runHTTPRequest = RunHTTPRequest.toJSON(message.runHTTPRequest);
    }
    if (message.runReadFile !== undefined) {
      obj.runReadFile = ReadFile.toJSON(message.runReadFile);
    }
    if (message.runWriteFile !== undefined) {
      obj.runWriteFile = WriteFile.toJSON(message.runWriteFile);
    }
    if (message.runGitCommand !== undefined) {
      obj.runGitCommand = RunGitCommand.toJSON(message.runGitCommand);
    }
    if (message.runEditFile !== undefined) {
      obj.runEditFile = EditFile.toJSON(message.runEditFile);
    }
    if (message.newCheckpoint !== undefined) {
      obj.newCheckpoint = NewCheckpoint.toJSON(message.newCheckpoint);
    }
    if (message.listDirectory !== undefined) {
      obj.listDirectory = ListDirectory.toJSON(message.listDirectory);
    }
    if (message.grep !== undefined) {
      obj.grep = Grep.toJSON(message.grep);
    }
    if (message.findFiles !== undefined) {
      obj.findFiles = FindFiles.toJSON(message.findFiles);
    }
    if (message.runMCPTool !== undefined) {
      obj.runMCPTool = RunMCPTool.toJSON(message.runMCPTool);
    }
    if (message.mkdir !== undefined) {
      obj.mkdir = Mkdir.toJSON(message.mkdir);
    }
    if (message.runReadFiles !== undefined) {
      obj.runReadFiles = ReadFiles.toJSON(message.runReadFiles);
    }
    if (message.runShellCommand !== undefined) {
      obj.runShellCommand = RunShellCommand.toJSON(message.runShellCommand);
    }
    if (message.trackLlmCallForSelfHosted !== undefined) {
      obj.trackLlmCallForSelfHosted = TrackLlmCallForSelfHosted.toJSON(message.trackLlmCallForSelfHosted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.requestID = object.requestID ?? "";
    message.runCommand = (object.runCommand !== undefined && object.runCommand !== null)
      ? RunCommandAction.fromPartial(object.runCommand)
      : undefined;
    message.runHTTPRequest = (object.runHTTPRequest !== undefined && object.runHTTPRequest !== null)
      ? RunHTTPRequest.fromPartial(object.runHTTPRequest)
      : undefined;
    message.runReadFile = (object.runReadFile !== undefined && object.runReadFile !== null)
      ? ReadFile.fromPartial(object.runReadFile)
      : undefined;
    message.runWriteFile = (object.runWriteFile !== undefined && object.runWriteFile !== null)
      ? WriteFile.fromPartial(object.runWriteFile)
      : undefined;
    message.runGitCommand = (object.runGitCommand !== undefined && object.runGitCommand !== null)
      ? RunGitCommand.fromPartial(object.runGitCommand)
      : undefined;
    message.runEditFile = (object.runEditFile !== undefined && object.runEditFile !== null)
      ? EditFile.fromPartial(object.runEditFile)
      : undefined;
    message.newCheckpoint = (object.newCheckpoint !== undefined && object.newCheckpoint !== null)
      ? NewCheckpoint.fromPartial(object.newCheckpoint)
      : undefined;
    message.listDirectory = (object.listDirectory !== undefined && object.listDirectory !== null)
      ? ListDirectory.fromPartial(object.listDirectory)
      : undefined;
    message.grep = (object.grep !== undefined && object.grep !== null) ? Grep.fromPartial(object.grep) : undefined;
    message.findFiles = (object.findFiles !== undefined && object.findFiles !== null)
      ? FindFiles.fromPartial(object.findFiles)
      : undefined;
    message.runMCPTool = (object.runMCPTool !== undefined && object.runMCPTool !== null)
      ? RunMCPTool.fromPartial(object.runMCPTool)
      : undefined;
    message.mkdir = (object.mkdir !== undefined && object.mkdir !== null) ? Mkdir.fromPartial(object.mkdir) : undefined;
    message.runReadFiles = (object.runReadFiles !== undefined && object.runReadFiles !== null)
      ? ReadFiles.fromPartial(object.runReadFiles)
      : undefined;
    message.runShellCommand = (object.runShellCommand !== undefined && object.runShellCommand !== null)
      ? RunShellCommand.fromPartial(object.runShellCommand)
      : undefined;
    message.trackLlmCallForSelfHosted =
      (object.trackLlmCallForSelfHosted !== undefined && object.trackLlmCallForSelfHosted !== null)
        ? TrackLlmCallForSelfHosted.fromPartial(object.trackLlmCallForSelfHosted)
        : undefined;
    return message;
  },
};

function createBaseTrackLlmCallForSelfHosted(): TrackLlmCallForSelfHosted {
  return { workflowID: "", featureQualifiedName: "", featureAiCatalogItem: false };
}

export const TrackLlmCallForSelfHosted: MessageFns<TrackLlmCallForSelfHosted> = {
  encode(message: TrackLlmCallForSelfHosted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowID !== "") {
      writer.uint32(10).string(message.workflowID);
    }
    if (message.featureQualifiedName !== "") {
      writer.uint32(18).string(message.featureQualifiedName);
    }
    if (message.featureAiCatalogItem !== false) {
      writer.uint32(24).bool(message.featureAiCatalogItem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackLlmCallForSelfHosted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackLlmCallForSelfHosted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.featureQualifiedName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.featureAiCatalogItem = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackLlmCallForSelfHosted {
    return {
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
      featureQualifiedName: isSet(object.featureQualifiedName) ? globalThis.String(object.featureQualifiedName) : "",
      featureAiCatalogItem: isSet(object.featureAiCatalogItem)
        ? globalThis.Boolean(object.featureAiCatalogItem)
        : false,
    };
  },

  toJSON(message: TrackLlmCallForSelfHosted): unknown {
    const obj: any = {};
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    if (message.featureQualifiedName !== "") {
      obj.featureQualifiedName = message.featureQualifiedName;
    }
    if (message.featureAiCatalogItem !== false) {
      obj.featureAiCatalogItem = message.featureAiCatalogItem;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackLlmCallForSelfHosted>, I>>(base?: I): TrackLlmCallForSelfHosted {
    return TrackLlmCallForSelfHosted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackLlmCallForSelfHosted>, I>>(object: I): TrackLlmCallForSelfHosted {
    const message = createBaseTrackLlmCallForSelfHosted();
    message.workflowID = object.workflowID ?? "";
    message.featureQualifiedName = object.featureQualifiedName ?? "";
    message.featureAiCatalogItem = object.featureAiCatalogItem ?? false;
    return message;
  },
};

function createBaseRunShellCommand(): RunShellCommand {
  return { command: "" };
}

export const RunShellCommand: MessageFns<RunShellCommand> = {
  encode(message: RunShellCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunShellCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunShellCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunShellCommand {
    return { command: isSet(object.command) ? globalThis.String(object.command) : "" };
  },

  toJSON(message: RunShellCommand): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunShellCommand>, I>>(base?: I): RunShellCommand {
    return RunShellCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunShellCommand>, I>>(object: I): RunShellCommand {
    const message = createBaseRunShellCommand();
    message.command = object.command ?? "";
    return message;
  },
};

function createBaseRunCommandAction(): RunCommandAction {
  return { program: "", arguments: [], flags: [] };
}

export const RunCommandAction: MessageFns<RunCommandAction> = {
  encode(message: RunCommandAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== "") {
      writer.uint32(26).string(message.program);
    }
    for (const v of message.arguments) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.flags) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunCommandAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunCommandAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.program = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.flags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunCommandAction {
    return {
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RunCommandAction): unknown {
    const obj: any = {};
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunCommandAction>, I>>(base?: I): RunCommandAction {
    return RunCommandAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunCommandAction>, I>>(object: I): RunCommandAction {
    const message = createBaseRunCommandAction();
    message.program = object.program ?? "";
    message.arguments = object.arguments?.map((e) => e) || [];
    message.flags = object.flags?.map((e) => e) || [];
    return message;
  },
};

function createBaseReadFile(): ReadFile {
  return { filepath: "", limit: undefined, offset: undefined };
}

export const ReadFile: MessageFns<ReadFile> = {
  encode(message: ReadFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int64(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int64(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
    };
  },

  toJSON(message: ReadFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFile>, I>>(base?: I): ReadFile {
    return ReadFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFile>, I>>(object: I): ReadFile {
    const message = createBaseReadFile();
    message.filepath = object.filepath ?? "";
    message.limit = object.limit ?? undefined;
    message.offset = object.offset ?? undefined;
    return message;
  },
};

function createBaseReadFiles(): ReadFiles {
  return { filepaths: [] };
}

export const ReadFiles: MessageFns<ReadFiles> = {
  encode(message: ReadFiles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filepaths) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFiles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepaths.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFiles {
    return {
      filepaths: globalThis.Array.isArray(object?.filepaths)
        ? object.filepaths.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ReadFiles): unknown {
    const obj: any = {};
    if (message.filepaths?.length) {
      obj.filepaths = message.filepaths;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFiles>, I>>(base?: I): ReadFiles {
    return ReadFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFiles>, I>>(object: I): ReadFiles {
    const message = createBaseReadFiles();
    message.filepaths = object.filepaths?.map((e) => e) || [];
    return message;
  },
};

function createBaseWriteFile(): WriteFile {
  return { filepath: "", contents: "" };
}

export const WriteFile: MessageFns<WriteFile> = {
  encode(message: WriteFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.contents !== "") {
      writer.uint32(18).string(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
    };
  },

  toJSON(message: WriteFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFile>, I>>(base?: I): WriteFile {
    return WriteFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFile>, I>>(object: I): WriteFile {
    const message = createBaseWriteFile();
    message.filepath = object.filepath ?? "";
    message.contents = object.contents ?? "";
    return message;
  },
};

function createBaseEditFile(): EditFile {
  return { filepath: "", oldString: "", newString: "" };
}

export const EditFile: MessageFns<EditFile> = {
  encode(message: EditFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filepath !== "") {
      writer.uint32(10).string(message.filepath);
    }
    if (message.oldString !== "") {
      writer.uint32(18).string(message.oldString);
    }
    if (message.newString !== "") {
      writer.uint32(26).string(message.newString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filepath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldString = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditFile {
    return {
      filepath: isSet(object.filepath) ? globalThis.String(object.filepath) : "",
      oldString: isSet(object.oldString) ? globalThis.String(object.oldString) : "",
      newString: isSet(object.newString) ? globalThis.String(object.newString) : "",
    };
  },

  toJSON(message: EditFile): unknown {
    const obj: any = {};
    if (message.filepath !== "") {
      obj.filepath = message.filepath;
    }
    if (message.oldString !== "") {
      obj.oldString = message.oldString;
    }
    if (message.newString !== "") {
      obj.newString = message.newString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditFile>, I>>(base?: I): EditFile {
    return EditFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditFile>, I>>(object: I): EditFile {
    const message = createBaseEditFile();
    message.filepath = object.filepath ?? "";
    message.oldString = object.oldString ?? "";
    message.newString = object.newString ?? "";
    return message;
  },
};

function createBaseRunHTTPRequest(): RunHTTPRequest {
  return { method: "", path: "", body: undefined };
}

export const RunHTTPRequest: MessageFns<RunHTTPRequest> = {
  encode(message: RunHTTPRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.body !== undefined) {
      writer.uint32(26).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunHTTPRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunHTTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunHTTPRequest {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : undefined,
    };
  },

  toJSON(message: RunHTTPRequest): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(base?: I): RunHTTPRequest {
    return RunHTTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunHTTPRequest>, I>>(object: I): RunHTTPRequest {
    const message = createBaseRunHTTPRequest();
    message.method = object.method ?? "";
    message.path = object.path ?? "";
    message.body = object.body ?? undefined;
    return message;
  },
};

function createBaseRunGitCommand(): RunGitCommand {
  return { command: "", arguments: undefined, repository_url: "" };
}

export const RunGitCommand: MessageFns<RunGitCommand> = {
  encode(message: RunGitCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.arguments !== undefined) {
      writer.uint32(18).string(message.arguments);
    }
    if (message.repository_url !== "") {
      writer.uint32(26).string(message.repository_url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunGitCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunGitCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repository_url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunGitCommand {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : undefined,
      repository_url: isSet(object.repository_url) ? globalThis.String(object.repository_url) : "",
    };
  },

  toJSON(message: RunGitCommand): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.arguments !== undefined) {
      obj.arguments = message.arguments;
    }
    if (message.repository_url !== "") {
      obj.repository_url = message.repository_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunGitCommand>, I>>(base?: I): RunGitCommand {
    return RunGitCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunGitCommand>, I>>(object: I): RunGitCommand {
    const message = createBaseRunGitCommand();
    message.command = object.command ?? "";
    message.arguments = object.arguments ?? undefined;
    message.repository_url = object.repository_url ?? "";
    return message;
  },
};

function createBaseGenerateTokenRequest(): GenerateTokenRequest {
  return { workflowDefinition: undefined };
}

export const GenerateTokenRequest: MessageFns<GenerateTokenRequest> = {
  encode(message: GenerateTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowDefinition !== undefined) {
      writer.uint32(10).string(message.workflowDefinition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowDefinition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTokenRequest {
    return {
      workflowDefinition: isSet(object.workflowDefinition) ? globalThis.String(object.workflowDefinition) : undefined,
    };
  },

  toJSON(message: GenerateTokenRequest): unknown {
    const obj: any = {};
    if (message.workflowDefinition !== undefined) {
      obj.workflowDefinition = message.workflowDefinition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(base?: I): GenerateTokenRequest {
    return GenerateTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenRequest>, I>>(object: I): GenerateTokenRequest {
    const message = createBaseGenerateTokenRequest();
    message.workflowDefinition = object.workflowDefinition ?? undefined;
    return message;
  },
};

function createBaseGenerateTokenResponse(): GenerateTokenResponse {
  return { token: "", expiresAt: 0 };
}

export const GenerateTokenResponse: MessageFns<GenerateTokenResponse> = {
  encode(message: GenerateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateTokenResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
    };
  },

  toJSON(message: GenerateTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(base?: I): GenerateTokenResponse {
    return GenerateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateTokenResponse>, I>>(object: I): GenerateTokenResponse {
    const message = createBaseGenerateTokenResponse();
    message.token = object.token ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function createBaseListToolsRequest(): ListToolsRequest {
  return {};
}

export const ListToolsRequest: MessageFns<ListToolsRequest> = {
  encode(_: ListToolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListToolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListToolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListToolsRequest {
    return {};
  },

  toJSON(_: ListToolsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListToolsRequest>, I>>(base?: I): ListToolsRequest {
    return ListToolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListToolsRequest>, I>>(_: I): ListToolsRequest {
    const message = createBaseListToolsRequest();
    return message;
  },
};

function createBaseListToolsResponse(): ListToolsResponse {
  return { tools: [], eval_dataset: [] };
}

export const ListToolsResponse: MessageFns<ListToolsResponse> = {
  encode(message: ListToolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tools) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    for (const v of message.eval_dataset) {
      Struct.encode(Struct.wrap(v!), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListToolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListToolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tools.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eval_dataset.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListToolsResponse {
    return {
      tools: globalThis.Array.isArray(object?.tools) ? [...object.tools] : [],
      eval_dataset: globalThis.Array.isArray(object?.eval_dataset) ? [...object.eval_dataset] : [],
    };
  },

  toJSON(message: ListToolsResponse): unknown {
    const obj: any = {};
    if (message.tools?.length) {
      obj.tools = message.tools;
    }
    if (message.eval_dataset?.length) {
      obj.eval_dataset = message.eval_dataset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListToolsResponse>, I>>(base?: I): ListToolsResponse {
    return ListToolsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListToolsResponse>, I>>(object: I): ListToolsResponse {
    const message = createBaseListToolsResponse();
    message.tools = object.tools?.map((e) => e) || [];
    message.eval_dataset = object.eval_dataset?.map((e) => e) || [];
    return message;
  },
};

function createBaseListFlowsRequest(): ListFlowsRequest {
  return { filters: undefined };
}

export const ListFlowsRequest: MessageFns<ListFlowsRequest> = {
  encode(message: ListFlowsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      ListFlowsRequestFilter.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlowsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlowsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = ListFlowsRequestFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlowsRequest {
    return { filters: isSet(object.filters) ? ListFlowsRequestFilter.fromJSON(object.filters) : undefined };
  },

  toJSON(message: ListFlowsRequest): unknown {
    const obj: any = {};
    if (message.filters !== undefined) {
      obj.filters = ListFlowsRequestFilter.toJSON(message.filters);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlowsRequest>, I>>(base?: I): ListFlowsRequest {
    return ListFlowsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlowsRequest>, I>>(object: I): ListFlowsRequest {
    const message = createBaseListFlowsRequest();
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? ListFlowsRequestFilter.fromPartial(object.filters)
      : undefined;
    return message;
  },
};

function createBaseListFlowsRequestFilter(): ListFlowsRequestFilter {
  return { flow_identifier: [], environment: [], version: [] };
}

export const ListFlowsRequestFilter: MessageFns<ListFlowsRequestFilter> = {
  encode(message: ListFlowsRequestFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flow_identifier) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.environment) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.version) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlowsRequestFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlowsRequestFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.flow_identifier.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlowsRequestFilter {
    return {
      flow_identifier: globalThis.Array.isArray(object?.flow_identifier)
        ? object.flow_identifier.map((e: any) => globalThis.String(e))
        : [],
      environment: globalThis.Array.isArray(object?.environment)
        ? object.environment.map((e: any) => globalThis.String(e))
        : [],
      version: globalThis.Array.isArray(object?.version) ? object.version.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListFlowsRequestFilter): unknown {
    const obj: any = {};
    if (message.flow_identifier?.length) {
      obj.flow_identifier = message.flow_identifier;
    }
    if (message.environment?.length) {
      obj.environment = message.environment;
    }
    if (message.version?.length) {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlowsRequestFilter>, I>>(base?: I): ListFlowsRequestFilter {
    return ListFlowsRequestFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlowsRequestFilter>, I>>(object: I): ListFlowsRequestFilter {
    const message = createBaseListFlowsRequestFilter();
    message.flow_identifier = object.flow_identifier?.map((e) => e) || [];
    message.environment = object.environment?.map((e) => e) || [];
    message.version = object.version?.map((e) => e) || [];
    return message;
  },
};

function createBaseListFlowsResponse(): ListFlowsResponse {
  return { configs: [] };
}

export const ListFlowsResponse: MessageFns<ListFlowsResponse> = {
  encode(message: ListFlowsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      Struct.encode(Struct.wrap(v!), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlowsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlowsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlowsResponse {
    return { configs: globalThis.Array.isArray(object?.configs) ? [...object.configs] : [] };
  },

  toJSON(message: ListFlowsResponse): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlowsResponse>, I>>(base?: I): ListFlowsResponse {
    return ListFlowsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlowsResponse>, I>>(object: I): ListFlowsResponse {
    const message = createBaseListFlowsResponse();
    message.configs = object.configs?.map((e) => e) || [];
    return message;
  },
};

function createBaseNewCheckpoint(): NewCheckpoint {
  return { status: "", checkpoint: "", goal: "", errors: [] };
}

export const NewCheckpoint: MessageFns<NewCheckpoint> = {
  encode(message: NewCheckpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.checkpoint !== "") {
      writer.uint32(18).string(message.checkpoint);
    }
    if (message.goal !== "") {
      writer.uint32(26).string(message.goal);
    }
    for (const v of message.errors) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewCheckpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewCheckpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewCheckpoint {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      checkpoint: isSet(object.checkpoint) ? globalThis.String(object.checkpoint) : "",
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NewCheckpoint): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.checkpoint !== "") {
      obj.checkpoint = message.checkpoint;
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewCheckpoint>, I>>(base?: I): NewCheckpoint {
    return NewCheckpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewCheckpoint>, I>>(object: I): NewCheckpoint {
    const message = createBaseNewCheckpoint();
    message.status = object.status ?? "";
    message.checkpoint = object.checkpoint ?? "";
    message.goal = object.goal ?? "";
    message.errors = object.errors?.map((e) => e) || [];
    return message;
  },
};

function createBaseListDirectory(): ListDirectory {
  return { directory: "" };
}

export const ListDirectory: MessageFns<ListDirectory> = {
  encode(message: ListDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directory !== "") {
      writer.uint32(10).string(message.directory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.directory = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDirectory {
    return { directory: isSet(object.directory) ? globalThis.String(object.directory) : "" };
  },

  toJSON(message: ListDirectory): unknown {
    const obj: any = {};
    if (message.directory !== "") {
      obj.directory = message.directory;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDirectory>, I>>(base?: I): ListDirectory {
    return ListDirectory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDirectory>, I>>(object: I): ListDirectory {
    const message = createBaseListDirectory();
    message.directory = object.directory ?? "";
    return message;
  },
};

function createBaseGrep(): Grep {
  return { search_directory: "", pattern: "", case_insensitive: false };
}

export const Grep: MessageFns<Grep> = {
  encode(message: Grep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search_directory !== "") {
      writer.uint32(10).string(message.search_directory);
    }
    if (message.pattern !== "") {
      writer.uint32(18).string(message.pattern);
    }
    if (message.case_insensitive !== false) {
      writer.uint32(24).bool(message.case_insensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Grep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search_directory = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.case_insensitive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Grep {
    return {
      search_directory: isSet(object.search_directory) ? globalThis.String(object.search_directory) : "",
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      case_insensitive: isSet(object.case_insensitive) ? globalThis.Boolean(object.case_insensitive) : false,
    };
  },

  toJSON(message: Grep): unknown {
    const obj: any = {};
    if (message.search_directory !== "") {
      obj.search_directory = message.search_directory;
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.case_insensitive !== false) {
      obj.case_insensitive = message.case_insensitive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Grep>, I>>(base?: I): Grep {
    return Grep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Grep>, I>>(object: I): Grep {
    const message = createBaseGrep();
    message.search_directory = object.search_directory ?? "";
    message.pattern = object.pattern ?? "";
    message.case_insensitive = object.case_insensitive ?? false;
    return message;
  },
};

function createBaseFindFiles(): FindFiles {
  return { name_pattern: "" };
}

export const FindFiles: MessageFns<FindFiles> = {
  encode(message: FindFiles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name_pattern !== "") {
      writer.uint32(10).string(message.name_pattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindFiles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name_pattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindFiles {
    return { name_pattern: isSet(object.name_pattern) ? globalThis.String(object.name_pattern) : "" };
  },

  toJSON(message: FindFiles): unknown {
    const obj: any = {};
    if (message.name_pattern !== "") {
      obj.name_pattern = message.name_pattern;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindFiles>, I>>(base?: I): FindFiles {
    return FindFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindFiles>, I>>(object: I): FindFiles {
    const message = createBaseFindFiles();
    message.name_pattern = object.name_pattern ?? "";
    return message;
  },
};

function createBaseMcpTool(): McpTool {
  return { name: "", description: "", inputSchema: "" };
}

export const McpTool: MessageFns<McpTool> = {
  encode(message: McpTool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.inputSchema !== "") {
      writer.uint32(26).string(message.inputSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpTool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpTool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      inputSchema: isSet(object.inputSchema) ? globalThis.String(object.inputSchema) : "",
    };
  },

  toJSON(message: McpTool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.inputSchema !== "") {
      obj.inputSchema = message.inputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpTool>, I>>(base?: I): McpTool {
    return McpTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpTool>, I>>(object: I): McpTool {
    const message = createBaseMcpTool();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.inputSchema = object.inputSchema ?? "";
    return message;
  },
};

function createBaseRunMCPTool(): RunMCPTool {
  return { name: "", args: "" };
}

export const RunMCPTool: MessageFns<RunMCPTool> = {
  encode(message: RunMCPTool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.args !== "") {
      writer.uint32(18).string(message.args);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunMCPTool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunMCPTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunMCPTool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      args: isSet(object.args) ? globalThis.String(object.args) : "",
    };
  },

  toJSON(message: RunMCPTool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.args !== "") {
      obj.args = message.args;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunMCPTool>, I>>(base?: I): RunMCPTool {
    return RunMCPTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunMCPTool>, I>>(object: I): RunMCPTool {
    const message = createBaseRunMCPTool();
    message.name = object.name ?? "";
    message.args = object.args ?? "";
    return message;
  },
};

function createBaseAdditionalContext(): AdditionalContext {
  return { category: "", id: undefined, content: undefined, metadata: undefined };
}

export const AdditionalContext: MessageFns<AdditionalContext> = {
  encode(message: AdditionalContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    if (message.content !== undefined) {
      writer.uint32(26).string(message.content);
    }
    if (message.metadata !== undefined) {
      writer.uint32(34).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdditionalContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalContext {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      content: isSet(object.content) ? globalThis.String(object.content) : undefined,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : undefined,
    };
  },

  toJSON(message: AdditionalContext): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdditionalContext>, I>>(base?: I): AdditionalContext {
    return AdditionalContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdditionalContext>, I>>(object: I): AdditionalContext {
    const message = createBaseAdditionalContext();
    message.category = object.category ?? "";
    message.id = object.id ?? undefined;
    message.content = object.content ?? undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseApproval(): Approval {
  return { approval: undefined, rejection: undefined };
}

export const Approval: MessageFns<Approval> = {
  encode(message: Approval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approval !== undefined) {
      Approval_Approved.encode(message.approval, writer.uint32(10).fork()).join();
    }
    if (message.rejection !== undefined) {
      Approval_Rejected.encode(message.rejection, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Approval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.approval = Approval_Approved.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rejection = Approval_Rejected.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Approval {
    return {
      approval: isSet(object.approval) ? Approval_Approved.fromJSON(object.approval) : undefined,
      rejection: isSet(object.rejection) ? Approval_Rejected.fromJSON(object.rejection) : undefined,
    };
  },

  toJSON(message: Approval): unknown {
    const obj: any = {};
    if (message.approval !== undefined) {
      obj.approval = Approval_Approved.toJSON(message.approval);
    }
    if (message.rejection !== undefined) {
      obj.rejection = Approval_Rejected.toJSON(message.rejection);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Approval>, I>>(base?: I): Approval {
    return Approval.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Approval>, I>>(object: I): Approval {
    const message = createBaseApproval();
    message.approval = (object.approval !== undefined && object.approval !== null)
      ? Approval_Approved.fromPartial(object.approval)
      : undefined;
    message.rejection = (object.rejection !== undefined && object.rejection !== null)
      ? Approval_Rejected.fromPartial(object.rejection)
      : undefined;
    return message;
  },
};

function createBaseApproval_Approved(): Approval_Approved {
  return { remember_approval: undefined, tool_name: undefined, tool_args_json: undefined };
}

export const Approval_Approved: MessageFns<Approval_Approved> = {
  encode(message: Approval_Approved, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remember_approval !== undefined) {
      writer.uint32(8).bool(message.remember_approval);
    }
    if (message.tool_name !== undefined) {
      writer.uint32(18).string(message.tool_name);
    }
    if (message.tool_args_json !== undefined) {
      writer.uint32(26).string(message.tool_args_json);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Approval_Approved {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproval_Approved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.remember_approval = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tool_name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tool_args_json = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Approval_Approved {
    return {
      remember_approval: isSet(object.remember_approval) ? globalThis.Boolean(object.remember_approval) : undefined,
      tool_name: isSet(object.tool_name) ? globalThis.String(object.tool_name) : undefined,
      tool_args_json: isSet(object.tool_args_json) ? globalThis.String(object.tool_args_json) : undefined,
    };
  },

  toJSON(message: Approval_Approved): unknown {
    const obj: any = {};
    if (message.remember_approval !== undefined) {
      obj.remember_approval = message.remember_approval;
    }
    if (message.tool_name !== undefined) {
      obj.tool_name = message.tool_name;
    }
    if (message.tool_args_json !== undefined) {
      obj.tool_args_json = message.tool_args_json;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Approval_Approved>, I>>(base?: I): Approval_Approved {
    return Approval_Approved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Approval_Approved>, I>>(object: I): Approval_Approved {
    const message = createBaseApproval_Approved();
    message.remember_approval = object.remember_approval ?? undefined;
    message.tool_name = object.tool_name ?? undefined;
    message.tool_args_json = object.tool_args_json ?? undefined;
    return message;
  },
};

function createBaseApproval_Rejected(): Approval_Rejected {
  return { message: undefined };
}

export const Approval_Rejected: MessageFns<Approval_Rejected> = {
  encode(message: Approval_Rejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Approval_Rejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproval_Rejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Approval_Rejected {
    return { message: isSet(object.message) ? globalThis.String(object.message) : undefined };
  },

  toJSON(message: Approval_Rejected): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Approval_Rejected>, I>>(base?: I): Approval_Rejected {
    return Approval_Rejected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Approval_Rejected>, I>>(object: I): Approval_Rejected {
    const message = createBaseApproval_Rejected();
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseMkdir(): Mkdir {
  return { directory_path: "" };
}

export const Mkdir: MessageFns<Mkdir> = {
  encode(message: Mkdir, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.directory_path !== "") {
      writer.uint32(10).string(message.directory_path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mkdir {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMkdir();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.directory_path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mkdir {
    return { directory_path: isSet(object.directory_path) ? globalThis.String(object.directory_path) : "" };
  },

  toJSON(message: Mkdir): unknown {
    const obj: any = {};
    if (message.directory_path !== "") {
      obj.directory_path = message.directory_path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mkdir>, I>>(base?: I): Mkdir {
    return Mkdir.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mkdir>, I>>(object: I): Mkdir {
    const message = createBaseMkdir();
    message.directory_path = object.directory_path ?? "";
    return message;
  },
};

function createBaseOsInformationContext(): OsInformationContext {
  return { platform: "", architecture: "" };
}

export const OsInformationContext: MessageFns<OsInformationContext> = {
  encode(message: OsInformationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platform !== "") {
      writer.uint32(10).string(message.platform);
    }
    if (message.architecture !== "") {
      writer.uint32(18).string(message.architecture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OsInformationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOsInformationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.architecture = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OsInformationContext {
    return {
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      architecture: isSet(object.architecture) ? globalThis.String(object.architecture) : "",
    };
  },

  toJSON(message: OsInformationContext): unknown {
    const obj: any = {};
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.architecture !== "") {
      obj.architecture = message.architecture;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OsInformationContext>, I>>(base?: I): OsInformationContext {
    return OsInformationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OsInformationContext>, I>>(object: I): OsInformationContext {
    const message = createBaseOsInformationContext();
    message.platform = object.platform ?? "";
    message.architecture = object.architecture ?? "";
    return message;
  },
};

function createBaseShellInformationContext(): ShellInformationContext {
  return {
    shell_name: "",
    shell_type: "",
    shell_variant: undefined,
    shell_environment: undefined,
    ssh_session: undefined,
    cwd: undefined,
  };
}

export const ShellInformationContext: MessageFns<ShellInformationContext> = {
  encode(message: ShellInformationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shell_name !== "") {
      writer.uint32(10).string(message.shell_name);
    }
    if (message.shell_type !== "") {
      writer.uint32(18).string(message.shell_type);
    }
    if (message.shell_variant !== undefined) {
      writer.uint32(26).string(message.shell_variant);
    }
    if (message.shell_environment !== undefined) {
      writer.uint32(34).string(message.shell_environment);
    }
    if (message.ssh_session !== undefined) {
      writer.uint32(40).bool(message.ssh_session);
    }
    if (message.cwd !== undefined) {
      writer.uint32(50).string(message.cwd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShellInformationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShellInformationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shell_name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shell_type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shell_variant = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shell_environment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ssh_session = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cwd = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShellInformationContext {
    return {
      shell_name: isSet(object.shell_name) ? globalThis.String(object.shell_name) : "",
      shell_type: isSet(object.shell_type) ? globalThis.String(object.shell_type) : "",
      shell_variant: isSet(object.shell_variant) ? globalThis.String(object.shell_variant) : undefined,
      shell_environment: isSet(object.shell_environment) ? globalThis.String(object.shell_environment) : undefined,
      ssh_session: isSet(object.ssh_session) ? globalThis.Boolean(object.ssh_session) : undefined,
      cwd: isSet(object.cwd) ? globalThis.String(object.cwd) : undefined,
    };
  },

  toJSON(message: ShellInformationContext): unknown {
    const obj: any = {};
    if (message.shell_name !== "") {
      obj.shell_name = message.shell_name;
    }
    if (message.shell_type !== "") {
      obj.shell_type = message.shell_type;
    }
    if (message.shell_variant !== undefined) {
      obj.shell_variant = message.shell_variant;
    }
    if (message.shell_environment !== undefined) {
      obj.shell_environment = message.shell_environment;
    }
    if (message.ssh_session !== undefined) {
      obj.ssh_session = message.ssh_session;
    }
    if (message.cwd !== undefined) {
      obj.cwd = message.cwd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShellInformationContext>, I>>(base?: I): ShellInformationContext {
    return ShellInformationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShellInformationContext>, I>>(object: I): ShellInformationContext {
    const message = createBaseShellInformationContext();
    message.shell_name = object.shell_name ?? "";
    message.shell_type = object.shell_type ?? "";
    message.shell_variant = object.shell_variant ?? undefined;
    message.shell_environment = object.shell_environment ?? undefined;
    message.ssh_session = object.ssh_session ?? undefined;
    message.cwd = object.cwd ?? undefined;
    return message;
  },
};

function createBaseTrackSelfHostedClientEvent(): TrackSelfHostedClientEvent {
  return { requestID: "", workflowID: "", featureQualifiedName: "", featureAiCatalogItem: false };
}

export const TrackSelfHostedClientEvent: MessageFns<TrackSelfHostedClientEvent> = {
  encode(message: TrackSelfHostedClientEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    if (message.workflowID !== "") {
      writer.uint32(18).string(message.workflowID);
    }
    if (message.featureQualifiedName !== "") {
      writer.uint32(26).string(message.featureQualifiedName);
    }
    if (message.featureAiCatalogItem !== false) {
      writer.uint32(32).bool(message.featureAiCatalogItem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackSelfHostedClientEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackSelfHostedClientEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.featureQualifiedName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.featureAiCatalogItem = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackSelfHostedClientEvent {
    return {
      requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "",
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
      featureQualifiedName: isSet(object.featureQualifiedName) ? globalThis.String(object.featureQualifiedName) : "",
      featureAiCatalogItem: isSet(object.featureAiCatalogItem)
        ? globalThis.Boolean(object.featureAiCatalogItem)
        : false,
    };
  },

  toJSON(message: TrackSelfHostedClientEvent): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    if (message.featureQualifiedName !== "") {
      obj.featureQualifiedName = message.featureQualifiedName;
    }
    if (message.featureAiCatalogItem !== false) {
      obj.featureAiCatalogItem = message.featureAiCatalogItem;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackSelfHostedClientEvent>, I>>(base?: I): TrackSelfHostedClientEvent {
    return TrackSelfHostedClientEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackSelfHostedClientEvent>, I>>(object: I): TrackSelfHostedClientEvent {
    const message = createBaseTrackSelfHostedClientEvent();
    message.requestID = object.requestID ?? "";
    message.workflowID = object.workflowID ?? "";
    message.featureQualifiedName = object.featureQualifiedName ?? "";
    message.featureAiCatalogItem = object.featureAiCatalogItem ?? false;
    return message;
  },
};

function createBaseTrackSelfHostedAction(): TrackSelfHostedAction {
  return { requestID: "" };
}

export const TrackSelfHostedAction: MessageFns<TrackSelfHostedAction> = {
  encode(message: TrackSelfHostedAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestID !== "") {
      writer.uint32(10).string(message.requestID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackSelfHostedAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackSelfHostedAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackSelfHostedAction {
    return { requestID: isSet(object.requestID) ? globalThis.String(object.requestID) : "" };
  },

  toJSON(message: TrackSelfHostedAction): unknown {
    const obj: any = {};
    if (message.requestID !== "") {
      obj.requestID = message.requestID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackSelfHostedAction>, I>>(base?: I): TrackSelfHostedAction {
    return TrackSelfHostedAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackSelfHostedAction>, I>>(object: I): TrackSelfHostedAction {
    const message = createBaseTrackSelfHostedAction();
    message.requestID = object.requestID ?? "";
    return message;
  },
};

export type DuoWorkflowService = typeof DuoWorkflowService;
export const DuoWorkflowService = {
  executeWorkflow: {
    path: "/DuoWorkflow/ExecuteWorkflow",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ClientEvent): Buffer => Buffer.from(ClientEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): ClientEvent => ClientEvent.decode(value),
    responseSerialize: (value: Action): Buffer => Buffer.from(Action.encode(value).finish()),
    responseDeserialize: (value: Buffer): Action => Action.decode(value),
  },
  generateToken: {
    path: "/DuoWorkflow/GenerateToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateTokenRequest): Buffer => Buffer.from(GenerateTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GenerateTokenRequest => GenerateTokenRequest.decode(value),
    responseSerialize: (value: GenerateTokenResponse): Buffer =>
      Buffer.from(GenerateTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GenerateTokenResponse => GenerateTokenResponse.decode(value),
  },
  listTools: {
    path: "/DuoWorkflow/ListTools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListToolsRequest): Buffer => Buffer.from(ListToolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListToolsRequest => ListToolsRequest.decode(value),
    responseSerialize: (value: ListToolsResponse): Buffer => Buffer.from(ListToolsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListToolsResponse => ListToolsResponse.decode(value),
  },
  listFlows: {
    path: "/DuoWorkflow/ListFlows",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListFlowsRequest): Buffer => Buffer.from(ListFlowsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListFlowsRequest => ListFlowsRequest.decode(value),
    responseSerialize: (value: ListFlowsResponse): Buffer => Buffer.from(ListFlowsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListFlowsResponse => ListFlowsResponse.decode(value),
  },
  trackSelfHostedExecuteWorkflow: {
    path: "/DuoWorkflow/TrackSelfHostedExecuteWorkflow",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: TrackSelfHostedClientEvent): Buffer =>
      Buffer.from(TrackSelfHostedClientEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): TrackSelfHostedClientEvent => TrackSelfHostedClientEvent.decode(value),
    responseSerialize: (value: TrackSelfHostedAction): Buffer =>
      Buffer.from(TrackSelfHostedAction.encode(value).finish()),
    responseDeserialize: (value: Buffer): TrackSelfHostedAction => TrackSelfHostedAction.decode(value),
  },
} as const;

export interface DuoWorkflowServer extends UntypedServiceImplementation {
  executeWorkflow: handleBidiStreamingCall<ClientEvent, Action>;
  generateToken: handleUnaryCall<GenerateTokenRequest, GenerateTokenResponse>;
  listTools: handleUnaryCall<ListToolsRequest, ListToolsResponse>;
  listFlows: handleUnaryCall<ListFlowsRequest, ListFlowsResponse>;
  trackSelfHostedExecuteWorkflow: handleBidiStreamingCall<TrackSelfHostedClientEvent, TrackSelfHostedAction>;
}

export interface DuoWorkflowClient extends Client {
  executeWorkflow(): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(options: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  executeWorkflow(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ClientEvent, Action>;
  generateToken(
    request: GenerateTokenRequest,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  generateToken(
    request: GenerateTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GenerateTokenResponse) => void,
  ): ClientUnaryCall;
  listTools(
    request: ListToolsRequest,
    callback: (error: ServiceError | null, response: ListToolsResponse) => void,
  ): ClientUnaryCall;
  listTools(
    request: ListToolsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListToolsResponse) => void,
  ): ClientUnaryCall;
  listTools(
    request: ListToolsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListToolsResponse) => void,
  ): ClientUnaryCall;
  listFlows(
    request: ListFlowsRequest,
    callback: (error: ServiceError | null, response: ListFlowsResponse) => void,
  ): ClientUnaryCall;
  listFlows(
    request: ListFlowsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListFlowsResponse) => void,
  ): ClientUnaryCall;
  listFlows(
    request: ListFlowsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListFlowsResponse) => void,
  ): ClientUnaryCall;
  trackSelfHostedExecuteWorkflow(): ClientDuplexStream<TrackSelfHostedClientEvent, TrackSelfHostedAction>;
  trackSelfHostedExecuteWorkflow(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<TrackSelfHostedClientEvent, TrackSelfHostedAction>;
  trackSelfHostedExecuteWorkflow(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<TrackSelfHostedClientEvent, TrackSelfHostedAction>;
}

export const DuoWorkflowClient = makeGenericClientConstructor(DuoWorkflowService, "DuoWorkflow") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DuoWorkflowClient;
  service: typeof DuoWorkflowService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
