import json
from unittest.mock import AsyncMock, Mock

import pytest

from duo_workflow_service.tools.vulnerabilities.get_vulnerability_details import (
    EvaluateVulnerabilityFalsePositiveStatus,
    GetVulnerabilityDetails,
    GetVulnerabilityDetailsInput,
)


@pytest.fixture
def vulnerability_details_data():
    """Fixture for detailed vulnerability data."""
    return {
        "id": "gid://gitlab/Vulnerability/567",
        "project": {
            "id": "gid://gitlab/Project/1",
            "fullPath": "toolbox/gitlab-smoke-tests",
        },
        "title": "SQL Injection in user authentication",
        "state": "DETECTED",
        "description": "A SQL injection vulnerability was found in the user authentication module.",
        "reportType": "SAST",
        "reachability": "CONFIRMED",
        "cveEnrichment": {
            "cve": "CVE-2023-12345",
            "epssScore": 0.85,
            "isKnownExploit": True,
        },
        "detectedAt": "2023-10-01T12:00:00Z",
        "dismissedAt": None,
        "initialDetectedPipeline": {
            "id": "gid://gitlab/Ci::Pipeline/123",
            "name": "security-scan",
            "createdAt": "2023-10-01T11:30:00Z",
        },
        "location": {
            "__typename": "VulnerabilityLocationSast",
            "blobPath": "app/models/user.rb",
            "file": "app/models/user.rb",
            "startLine": 42,
        },
        "latestFlag": {
            "id": "gid://gitlab/VulnerabilityFlag/1",
            "status": "DETECTED_AS_FP",
            "confidenceScore": 0.92,
            "origin": "AI_DETECTION",
            "description": "Likely false positive - context suggests this is not exploitable",
            "createdAt": "2023-10-01T12:30:00Z",
            "updatedAt": "2023-10-01T12:30:00Z",
        },
        "details": [
            {
                "__typename": "VulnerabilityDetailText",
                "name": "Summary",
                "value": "SQL injection vulnerability detected",
            },
            {
                "__typename": "VulnerabilityDetailFileLocation",
                "name": "Location",
                "fileName": "app/models/user.rb",
                "lineStart": 42,
                "lineEnd": 45,
            },
        ],
    }


@pytest.fixture
def gitlab_client_mock():
    return Mock()


@pytest.fixture
def metadata(gitlab_client_mock):
    return {
        "gitlab_client": gitlab_client_mock,
        "gitlab_host": "gitlab.com",
    }


@pytest.mark.asyncio
async def test_get_vulnerability_details(
    gitlab_client_mock, metadata, vulnerability_details_data
):
    gitlab_client_mock.apost = AsyncMock(
        return_value={"data": {"vulnerability": vulnerability_details_data}}
    )

    tool = GetVulnerabilityDetails(metadata=metadata)

    input_data = {
        "vulnerability_id": "567",
    }

    response = await tool.arun(input_data)

    expected_response = json.dumps(
        {
            "vulnerability": vulnerability_details_data,
        }
    )
    assert response == expected_response

    gitlab_client_mock.apost.assert_called_once()
    call_args = gitlab_client_mock.apost.call_args
    assert call_args[1]["path"] == "/api/graphql"

    body = json.loads(call_args[1]["body"])
    assert body["variables"]["vulnerabilityId"] == "gid://gitlab/Vulnerability/567"
    assert "vulnerability(id: $vulnerabilityId)" in body["query"]


@pytest.mark.asyncio
async def test_get_vulnerability_details_not_found(gitlab_client_mock, metadata):
    gitlab_client_mock.apost = AsyncMock(return_value={"data": {"vulnerability": None}})

    tool = GetVulnerabilityDetails(metadata=metadata)

    input_data = {
        "vulnerability_id": "999",
    }

    response = await tool.arun(input_data)

    error_response = json.loads(response)
    assert "error" in error_response
    assert "Vulnerability with ID 999 not found" in error_response["error"]


@pytest.mark.asyncio
async def test_get_vulnerability_details_graphql_error(gitlab_client_mock, metadata):
    gitlab_client_mock.apost = AsyncMock(
        return_value={
            "errors": [
                {
                    "message": "Variable $vulnerabilityId of type ID! was provided invalid value",
                    "locations": [{"line": 1, "column": 1}],
                }
            ]
        }
    )

    tool = GetVulnerabilityDetails(metadata=metadata)

    input_data = {
        "vulnerability_id": "invalid-id",
    }

    response = await tool.arun(input_data)

    error_response = json.loads(response)
    assert "error" in error_response
    assert (
        "Invalid vulnerability ID: invalid-id. Must be numeric."
        in error_response["error"]
    )


@pytest.mark.asyncio
async def test_get_vulnerability_details_exception(gitlab_client_mock, metadata):
    gitlab_client_mock.apost = AsyncMock(side_effect=Exception("Network Error"))

    tool = GetVulnerabilityDetails(metadata=metadata)

    input_data = {
        "vulnerability_id": "567",
    }

    response = await tool.arun(input_data)

    error_response = json.loads(response)
    assert "error" in error_response
    assert "Network Error" in error_response["error"]


def test_get_vulnerability_details_format_display_message():
    tool = GetVulnerabilityDetails(metadata={})
    input_data = GetVulnerabilityDetailsInput(vulnerability_id="567")
    expected_message = "Get details for vulnerability 567"
    assert tool.format_display_message(input_data) == expected_message


@pytest.mark.asyncio
async def test_get_vulnerability_details_with_fp_metadata(
    gitlab_client_mock, metadata, vulnerability_details_data
):
    """Test that latestFlag FP detection metadata is returned in details."""
    gitlab_client_mock.apost = AsyncMock(
        return_value={"data": {"vulnerability": vulnerability_details_data}}
    )

    tool = GetVulnerabilityDetails(metadata=metadata)

    input_data = {
        "vulnerability_id": "567",
    }

    response = await tool.arun(input_data)

    response_data = json.loads(response)
    assert "vulnerability" in response_data
    vuln = response_data["vulnerability"]

    # Verify latestFlag is present
    assert "latestFlag" in vuln
    assert vuln["latestFlag"]["status"] == "DETECTED_AS_FP"
    assert vuln["latestFlag"]["confidenceScore"] == 0.92
    assert vuln["latestFlag"]["origin"] == "AI_DETECTION"
    assert "false positive" in vuln["latestFlag"]["description"].lower()
    assert "createdAt" in vuln["latestFlag"]
    assert "updatedAt" in vuln["latestFlag"]


@pytest.mark.asyncio
async def test_evaluate_fp_status_skip_false_positive():
    """High confidence score should return skip_false_positive."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    vuln_json = json.dumps(
        {
            "vulnerability": {
                "id": "gid://gitlab/Vulnerability/3340",
                "latestFlag": {
                    "status": "NOT_STARTED",
                    "confidenceScore": 0.95,
                    "origin": "ai_sast_fp_detection",
                },
            }
        }
    )

    result = await tool.arun({"vulnerability_json": vuln_json})
    assert result == "skip_false_positive"


@pytest.mark.asyncio
async def test_evaluate_fp_status_proceed_with_fix():
    """Low confidence score should return proceed_with_fix."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    vuln_json = json.dumps(
        {
            "vulnerability": {
                "id": "gid://gitlab/Vulnerability/123",
                "latestFlag": {
                    "status": "NOT_STARTED",
                    "confidenceScore": 0.3,
                    "origin": "ai_sast_fp_detection",
                },
            }
        }
    )

    result = await tool.arun({"vulnerability_json": vuln_json})
    assert result == "proceed_with_fix"


@pytest.mark.asyncio
async def test_evaluate_fp_status_needs_analysis_no_flag():
    """No latestFlag should return proceed_with_fix."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    vuln_json = json.dumps(
        {"vulnerability": {"id": "gid://gitlab/Vulnerability/123", "latestFlag": None}}
    )

    result = await tool.arun({"vulnerability_json": vuln_json})
    assert result == "proceed_with_fix"


@pytest.mark.asyncio
async def test_evaluate_fp_status_threshold_boundary():
    """Exactly at threshold (0.6) should return skip_false_positive."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    vuln_json = json.dumps({"vulnerability": {"latestFlag": {"confidenceScore": 0.6}}})

    result = await tool.arun({"vulnerability_json": vuln_json})
    assert result == "skip_false_positive"


@pytest.mark.asyncio
async def test_evaluate_fp_status_below_threshold():
    """Just below threshold should return proceed_with_fix."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    vuln_json = json.dumps({"vulnerability": {"latestFlag": {"confidenceScore": 0.59}}})

    result = await tool.arun({"vulnerability_json": vuln_json})
    assert result == "proceed_with_fix"


@pytest.mark.asyncio
async def test_evaluate_fp_status_malformed_json():
    """Malformed JSON should return proceed_with_fix."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    result = await tool.arun({"vulnerability_json": "not valid json"})
    assert result == "proceed_with_fix"


@pytest.mark.asyncio
async def test_evaluate_fp_status_empty_string():
    """Empty string should return proceed_with_fix."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    result = await tool.arun({"vulnerability_json": ""})
    assert result == "proceed_with_fix"


@pytest.mark.asyncio
async def test_evaluate_fp_status_missing_vulnerability_key():
    """JSON without vulnerability key should return proceed_with_fix."""
    tool = EvaluateVulnerabilityFalsePositiveStatus(metadata={})

    vuln_json = json.dumps({"other_key": "value"})
    result = await tool.arun({"vulnerability_json": vuln_json})
    assert result == "proceed_with_fix"
